/* automatically generated by rust-bindgen 0.66.1 */

pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type stack_t = __darwin_sigaltstack;
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
pub type siginfo_t = __siginfo;
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rlim_t = __uint64_t;
pub type rusage_info_t = *mut ::std::os::raw::c_void;
pub type rusage_info_current = rusage_info_v6;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
#[doc = " Exported types\n - term = index in a term table\n - type = index in a type table"]
pub type term_t = i32;
pub type type_t = i32;
#[doc = " Context and models (opaque types)"]
pub type context_t = context_s;
pub type model_t = model_s;
#[doc = " Context configuration (opaque type)"]
pub type ctx_config_t = ctx_config_s;
#[doc = " Search parameters (opaque type)"]
pub type param_t = param_s;
#[doc = " Some functions return a collection of terms or types\n via a vector. The vector is an array that gets resized\n by the library as needed.\n\n For each vector type, the API provide three functions:\n - yices_init_xxx_vector(xxx_vector_t *v)\n - yices_reset_xxx_vector(xxx_vector_t *v)\n - yices_delete_xxx_vector(xxx_vector_t *v)\n\n The first function must be called first to initialize a vector.\n The reset function can be used to empty vector v. It just resets\n v->size to zero.\n The delete function must be called to delete a vector that is no\n longer needed. This is required to avoid memory leaks."]
pub type term_vector_t = term_vector_s;
pub type type_vector_t = type_vector_s;
#[doc = " Node descriptor"]
pub type yval_t = yval_s;
#[doc = " Vector of node descriptors"]
pub type yval_vector_t = yval_vector_s;
#[doc = " Error report = a code + line and column + 1 or 2 terms + 1 or 2 types\n + an (erroneous) integer value.\n\n The yices API returns a negative number and set an error code on\n error. The fields other than the error code depend on the code.  In\n addition, the parsing functions (yices_parse_type and\n yices_parse_term) set the line/column fields on error.\n\n  error code                 meaningful fields\n\n  NO_ERROR                   none\n\n  INVALID_TYPE               type1\n  INVALID_TERM               term1\n  INVALID_CONSTANT_INDEX     type1, badval\n  INVALID_VAR_INDEX          badval\n  INVALID_TUPLE_INDEX        type1, badval\n  INVALID_RATIONAL_FORMAT    none\n  INVALID_FLOAT_FORMAT       none\n  INVALID_BVBIN_FORMAT       none\n  INVALID_BVHEX_FORMAT       none\n  INVALID_BITSHIFT           badval\n  INVALID_BVEXTRACT          none\n  INVALID_BITEXTRACT         none\n  TOO_MANY_ARGUMENTS         badval\n  TOO_MANY_VARS              badval\n  MAX_BVSIZE_EXCEEDED        badval\n  DEGREE_OVERFLOW            badval\n  DIVISION_BY_ZERO           none\n  POS_INT_REQUIRED           badval\n  NONNEG_INT_REQUIRED        none\n  SCALAR_OR_UTYPE_REQUIRED   type1\n  FUNCTION_REQUIRED          term1\n  TUPLE_REQUIRED             term1\n  VARIABLE_REQUIRED          term1\n  ARITHTERM_REQUIRED         term1\n  BITVECTOR_REQUIRED         term1\n  SCALAR_TERM_REQUIRED       term1\n  WRONG_NUMBER_OF_ARGUMENTS  type1, badval\n  TYPE_MISMATCH              term1, type1\n  INCOMPATIBLE_TYPES         term1, type1, term2, type2\n  DUPLICATE_VARIABLE         term1\n  INCOMPATIBLE_BVSIZES       none\n  EMPTY_BITVECTOR            none\n  ARITHCONSTANT_REQUIRED     term1\n  INVALID_MACRO              badval\n  TOO_MANY_MACRO_PARAMS      badval\n  TYPE_VAR_REQUIRED          type1\n  DUPLICATE_TYPE_VAR         type1\n  BVTYPE_REQUIRED            type1\n  BAD_TERM_DECREF            term1\n  BAD_TYPE_DECREF            type1\n\n The following error codes are used only by the parsing functions.\n No field other than line/column is set.\n\n  INVALID_TOKEN\n  SYNTAX_ERROR\n  UNDEFINED_TERM_NAME\n  UNDEFINED_TYPE_NAME\n  REDEFINED_TERM_NAME\n  REDEFINED_TYPE_NAME\n  DUPLICATE_NAME_IN_SCALAR\n  DUPLICATE_VAR_NAME\n  INTEGER_OVERFLOW\n  INTEGER_REQUIRED\n  RATIONAL_REQUIRED\n  SYMBOL_REQUIRED\n  TYPE_REQUIRED\n  NON_CONSTANT_DIVISOR\n  NEGATIVE_BVSIZE\n  INVALID_BVCONSTANT\n  TYPE_MISMATCH_IN_DEF\n  ARITH_ERROR\n  BVARITH_ERROR\n\n The following error codes are triggered by invalid operations\n on a context. For these errors, no fields of error_report (other\n than the code) is meaningful.\n\n  CTX_FREE_VAR_IN_FORMULA\n  CTX_LOGIC_NOT_SUPPORTED\n  CTX_UF_NOT_SUPPORTED\n  CTX_ARITH_NOT_SUPPORTED\n  CTX_BV_NOT_SUPPORTED\n  CTX_ARRAYS_NOT_SUPPORTED\n  CTX_QUANTIFIERS_NOT_SUPPORTED\n  CTX_LAMBDAS_NOT_SUPPORTED\n  CTX_NONLINEAR_ARITH_NOT_SUPPORTED\n  CTX_FORMULA_NOT_IDL\n  CTX_FORMULA_NOT_RDL\n  CTX_TOO_MANY_ARITH_VARS\n  CTX_TOO_MANY_ARITH_ATOMS\n  CTX_TOO_MANY_BV_VARS\n  CTX_TOO_MANY_BV_ATOMS\n  CTX_ARITH_SOLVER_EXCEPTION\n  CTX_BV_SOLVER_EXCEPTION\n  CTX_ARRAY_SOLVER_EXCEPTION\n  CTX_SCALAR_NOT_SUPPORTED,\n  CTX_TUPLE_NOT_SUPPORTED,\n  CTX_UTYPE_NOT_SUPPORTED,\n\n  CTX_INVALID_OPERATION\n  CTX_OPERATION_NOT_SUPPORTED\n\n  CTX_UNKNOWN_DELEGATE\n  CTX_DELEGATE_NOT_AVAILABLE\n\n  CTX_INVALID_CONFIG\n  CTX_UNKNOWN_PARAMETER\n  CTX_INVALID_PARAMETER_VALUE\n  CTX_UNKNOWN_LOGIC\n\n\n Errors for functions that operate on a model (i.e., evaluate\n terms in a model).\n  EVAL_UNKNOWN_TERM\n  EVAL_FREEVAR_IN_TERM\n  EVAL_QUANTIFIER\n  EVAL_LAMBDA\n  EVAL_OVERFLOW\n  EVAL_FAILED\n  EVAL_CONVERSION_FAILED\n  EVAL_NO_IMPLICANT\n\n\n Other error codes. No field is meaningful in the error_report,\n except the error code:\n\n  OUTPUT_ERROR\n  INTERNAL_EXCEPTION"]
pub type error_report_t = error_report_s;
#[doc = " A context for interpolation. It consists of two regular context objects\n ctx_A and ctx_B. The ctx_A context should be a context with MCSAT enabled\n and model interpolation enabled."]
pub type interpolation_context_t = interpolation_context_s;
pub type va_list = __darwin_va_list;
pub type fpos_t = __darwin_off_t;
pub type FILE = __sFILE;
pub type off_t = __darwin_off_t;
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
    pub __bindgen_padding_0: [u8; 8usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
    pub __bindgen_padding_0: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
    pub __bindgen_padding_0: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_reserved: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct context_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct model_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctx_config_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct param_s {
    _unused: [u8; 0],
}
#[doc = " Some functions return a collection of terms or types\n via a vector. The vector is an array that gets resized\n by the library as needed.\n\n For each vector type, the API provide three functions:\n - yices_init_xxx_vector(xxx_vector_t *v)\n - yices_reset_xxx_vector(xxx_vector_t *v)\n - yices_delete_xxx_vector(xxx_vector_t *v)\n\n The first function must be called first to initialize a vector.\n The reset function can be used to empty vector v. It just resets\n v->size to zero.\n The delete function must be called to delete a vector that is no\n longer needed. This is required to avoid memory leaks."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct term_vector_s {
    pub capacity: u32,
    pub size: u32,
    pub data: *mut term_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct type_vector_s {
    pub capacity: u32,
    pub size: u32,
    pub data: *mut type_t,
}
#[doc = " Node descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct yval_s {
    pub node_id: i32,
    pub node_tag: yval_tag_t,
}
#[doc = " Vector of node descriptors"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct yval_vector_s {
    pub capacity: u32,
    pub size: u32,
    pub data: *mut yval_t,
}
#[doc = " Error report = a code + line and column + 1 or 2 terms + 1 or 2 types\n + an (erroneous) integer value.\n\n The yices API returns a negative number and set an error code on\n error. The fields other than the error code depend on the code.  In\n addition, the parsing functions (yices_parse_type and\n yices_parse_term) set the line/column fields on error.\n\n  error code                 meaningful fields\n\n  NO_ERROR                   none\n\n  INVALID_TYPE               type1\n  INVALID_TERM               term1\n  INVALID_CONSTANT_INDEX     type1, badval\n  INVALID_VAR_INDEX          badval\n  INVALID_TUPLE_INDEX        type1, badval\n  INVALID_RATIONAL_FORMAT    none\n  INVALID_FLOAT_FORMAT       none\n  INVALID_BVBIN_FORMAT       none\n  INVALID_BVHEX_FORMAT       none\n  INVALID_BITSHIFT           badval\n  INVALID_BVEXTRACT          none\n  INVALID_BITEXTRACT         none\n  TOO_MANY_ARGUMENTS         badval\n  TOO_MANY_VARS              badval\n  MAX_BVSIZE_EXCEEDED        badval\n  DEGREE_OVERFLOW            badval\n  DIVISION_BY_ZERO           none\n  POS_INT_REQUIRED           badval\n  NONNEG_INT_REQUIRED        none\n  SCALAR_OR_UTYPE_REQUIRED   type1\n  FUNCTION_REQUIRED          term1\n  TUPLE_REQUIRED             term1\n  VARIABLE_REQUIRED          term1\n  ARITHTERM_REQUIRED         term1\n  BITVECTOR_REQUIRED         term1\n  SCALAR_TERM_REQUIRED       term1\n  WRONG_NUMBER_OF_ARGUMENTS  type1, badval\n  TYPE_MISMATCH              term1, type1\n  INCOMPATIBLE_TYPES         term1, type1, term2, type2\n  DUPLICATE_VARIABLE         term1\n  INCOMPATIBLE_BVSIZES       none\n  EMPTY_BITVECTOR            none\n  ARITHCONSTANT_REQUIRED     term1\n  INVALID_MACRO              badval\n  TOO_MANY_MACRO_PARAMS      badval\n  TYPE_VAR_REQUIRED          type1\n  DUPLICATE_TYPE_VAR         type1\n  BVTYPE_REQUIRED            type1\n  BAD_TERM_DECREF            term1\n  BAD_TYPE_DECREF            type1\n\n The following error codes are used only by the parsing functions.\n No field other than line/column is set.\n\n  INVALID_TOKEN\n  SYNTAX_ERROR\n  UNDEFINED_TERM_NAME\n  UNDEFINED_TYPE_NAME\n  REDEFINED_TERM_NAME\n  REDEFINED_TYPE_NAME\n  DUPLICATE_NAME_IN_SCALAR\n  DUPLICATE_VAR_NAME\n  INTEGER_OVERFLOW\n  INTEGER_REQUIRED\n  RATIONAL_REQUIRED\n  SYMBOL_REQUIRED\n  TYPE_REQUIRED\n  NON_CONSTANT_DIVISOR\n  NEGATIVE_BVSIZE\n  INVALID_BVCONSTANT\n  TYPE_MISMATCH_IN_DEF\n  ARITH_ERROR\n  BVARITH_ERROR\n\n The following error codes are triggered by invalid operations\n on a context. For these errors, no fields of error_report (other\n than the code) is meaningful.\n\n  CTX_FREE_VAR_IN_FORMULA\n  CTX_LOGIC_NOT_SUPPORTED\n  CTX_UF_NOT_SUPPORTED\n  CTX_ARITH_NOT_SUPPORTED\n  CTX_BV_NOT_SUPPORTED\n  CTX_ARRAYS_NOT_SUPPORTED\n  CTX_QUANTIFIERS_NOT_SUPPORTED\n  CTX_LAMBDAS_NOT_SUPPORTED\n  CTX_NONLINEAR_ARITH_NOT_SUPPORTED\n  CTX_FORMULA_NOT_IDL\n  CTX_FORMULA_NOT_RDL\n  CTX_TOO_MANY_ARITH_VARS\n  CTX_TOO_MANY_ARITH_ATOMS\n  CTX_TOO_MANY_BV_VARS\n  CTX_TOO_MANY_BV_ATOMS\n  CTX_ARITH_SOLVER_EXCEPTION\n  CTX_BV_SOLVER_EXCEPTION\n  CTX_ARRAY_SOLVER_EXCEPTION\n  CTX_SCALAR_NOT_SUPPORTED,\n  CTX_TUPLE_NOT_SUPPORTED,\n  CTX_UTYPE_NOT_SUPPORTED,\n\n  CTX_INVALID_OPERATION\n  CTX_OPERATION_NOT_SUPPORTED\n\n  CTX_UNKNOWN_DELEGATE\n  CTX_DELEGATE_NOT_AVAILABLE\n\n  CTX_INVALID_CONFIG\n  CTX_UNKNOWN_PARAMETER\n  CTX_INVALID_PARAMETER_VALUE\n  CTX_UNKNOWN_LOGIC\n\n\n Errors for functions that operate on a model (i.e., evaluate\n terms in a model).\n  EVAL_UNKNOWN_TERM\n  EVAL_FREEVAR_IN_TERM\n  EVAL_QUANTIFIER\n  EVAL_LAMBDA\n  EVAL_OVERFLOW\n  EVAL_FAILED\n  EVAL_CONVERSION_FAILED\n  EVAL_NO_IMPLICANT\n\n\n Other error codes. No field is meaningful in the error_report,\n except the error code:\n\n  OUTPUT_ERROR\n  INTERNAL_EXCEPTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct error_report_s {
    pub code: error_code_t,
    pub line: u32,
    pub column: u32,
    pub term1: term_t,
    pub type1: type_t,
    pub term2: term_t,
    pub type2: type_t,
    pub __bindgen_padding_0: [u8; 4usize],
    pub badval: i64,
}
#[doc = " A context for interpolation. It consists of two regular context objects\n ctx_A and ctx_B. The ctx_A context should be a context with MCSAT enabled\n and model interpolation enabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct interpolation_context_s {
    pub ctx_A: *mut context_t,
    pub ctx_B: *mut context_t,
    pub interpolant: term_t,
    pub __bindgen_padding_0: [u8; 4usize],
    pub model: *mut model_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub __bindgen_padding_0: [u8; 4usize],
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub __bindgen_padding_1: [u8; 4usize],
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub __bindgen_padding_2: [u8; 4usize],
    pub _offset: fpos_t,
}
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
#[allow(unsafe_code)]
pub const __DARWIN_SUF_EXTSN: &::std::ffi::CStr =
    unsafe { ::std::ffi::CStr::from_bytes_with_nul_unchecked(b"$DARWIN_EXTSN\0") };
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const YICES_EXIT_OUT_OF_MEMORY: u32 = 16;
pub const YICES_EXIT_SYNTAX_ERROR: u32 = 17;
pub const YICES_EXIT_FILE_NOT_FOUND: u32 = 18;
pub const YICES_EXIT_USAGE: u32 = 19;
pub const YICES_EXIT_ERROR: u32 = 20;
pub const YICES_EXIT_INTERRUPTED: u32 = 21;
pub const YICES_EXIT_INTERNAL_ERROR: u32 = 22;
pub const YICES_EXIT_SYSTEM_ERROR: u32 = 23;
pub const YICES_EXIT_TLS_ERROR: u32 = 24;
pub const YICES_EXIT_SUCCESS: u32 = 0;
pub const YICES_MAX_TYPES: u32 = 536870911;
pub const YICES_MAX_TERMS: u32 = 536870911;
pub const YICES_MAX_ARITY: u32 = 268435455;
pub const YICES_MAX_DEGREE: u32 = 2147483647;
pub const YICES_MAX_VARS: u32 = 268435455;
pub const YICES_MAX_BVSIZE: u32 = 268435455;
pub const NULL_TERM: i32 = -1;
pub const NULL_TYPE: i32 = -1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
#[allow(unsafe_code)]
pub const P_tmpdir: &::std::ffi::CStr =
    unsafe { ::std::ffi::CStr::from_bytes_with_nul_unchecked(b"/var/tmp/\0") };
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __YICES_VERSION: u32 = 2;
pub const __YICES_VERSION_MAJOR: u32 = 6;
pub const __YICES_VERSION_PATCHLEVEL: u32 = 4;
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[test]
fn bindgen_test_layout_term_vector_s() {
    const UNINIT: ::std::mem::MaybeUninit<term_vector_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<term_vector_s>(),
        16usize,
        concat!("Size of: ", stringify!(term_vector_s))
    );
    assert_eq!(
        ::std::mem::align_of::<term_vector_s>(),
        8usize,
        concat!("Alignment of ", stringify!(term_vector_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(term_vector_s),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(term_vector_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(term_vector_s),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_type_vector_s() {
    const UNINIT: ::std::mem::MaybeUninit<type_vector_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_vector_s>(),
        16usize,
        concat!("Size of: ", stringify!(type_vector_s))
    );
    assert_eq!(
        ::std::mem::align_of::<type_vector_s>(),
        8usize,
        concat!("Alignment of ", stringify!(type_vector_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_vector_s),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(type_vector_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_vector_s),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_yval_s() {
    const UNINIT: ::std::mem::MaybeUninit<yval_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<yval_s>(),
        8usize,
        concat!("Size of: ", stringify!(yval_s))
    );
    assert_eq!(
        ::std::mem::align_of::<yval_s>(),
        4usize,
        concat!("Alignment of ", stringify!(yval_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(yval_s),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_tag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(yval_s),
            "::",
            stringify!(node_tag)
        )
    );
}
#[test]
fn bindgen_test_layout_yval_vector_s() {
    const UNINIT: ::std::mem::MaybeUninit<yval_vector_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<yval_vector_s>(),
        16usize,
        concat!("Size of: ", stringify!(yval_vector_s))
    );
    assert_eq!(
        ::std::mem::align_of::<yval_vector_s>(),
        8usize,
        concat!("Alignment of ", stringify!(yval_vector_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(yval_vector_s),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(yval_vector_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(yval_vector_s),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_error_report_s() {
    const UNINIT: ::std::mem::MaybeUninit<error_report_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<error_report_s>(),
        40usize,
        concat!("Size of: ", stringify!(error_report_s))
    );
    assert_eq!(
        ::std::mem::align_of::<error_report_s>(),
        8usize,
        concat!("Alignment of ", stringify!(error_report_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(term1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(type1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(term2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(type2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).badval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(error_report_s),
            "::",
            stringify!(badval)
        )
    );
}
#[test]
fn bindgen_test_layout_interpolation_context_s() {
    const UNINIT: ::std::mem::MaybeUninit<interpolation_context_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<interpolation_context_s>(),
        32usize,
        concat!("Size of: ", stringify!(interpolation_context_s))
    );
    assert_eq!(
        ::std::mem::align_of::<interpolation_context_s>(),
        8usize,
        concat!("Alignment of ", stringify!(interpolation_context_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_A) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interpolation_context_s),
            "::",
            stringify!(ctx_A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_B) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interpolation_context_s),
            "::",
            stringify!(ctx_B)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interpolant) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(interpolation_context_s),
            "::",
            stringify!(interpolant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).model) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(interpolation_context_s),
            "::",
            stringify!(model)
        )
    );
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
#[repr(u32)]
#[doc = " Context status code"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum smt_status {
    STATUS_IDLE = 0,
    STATUS_SEARCHING = 1,
    STATUS_UNKNOWN = 2,
    STATUS_SAT = 3,
    STATUS_UNSAT = 4,
    STATUS_INTERRUPTED = 5,
    STATUS_ERROR = 6,
}
#[repr(i32)]
#[doc = " These codes are part of the term exploration API."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum term_constructor {
    #[doc = " to report an error"]
    YICES_CONSTRUCTOR_ERROR = -1,
    #[doc = " boolean constant"]
    YICES_BOOL_CONSTANT = 0,
    #[doc = " rational constant"]
    YICES_ARITH_CONSTANT = 1,
    #[doc = " bitvector constant"]
    YICES_BV_CONSTANT = 2,
    #[doc = " constant of uninterpreted/scalar"]
    YICES_SCALAR_CONSTANT = 3,
    #[doc = " variable in quantifiers"]
    YICES_VARIABLE = 4,
    #[doc = " (i.e., global variables, can't be bound)"]
    YICES_UNINTERPRETED_TERM = 5,
    #[doc = " if-then-else"]
    YICES_ITE_TERM = 6,
    #[doc = " application of an uninterpreted function"]
    YICES_APP_TERM = 7,
    #[doc = " function update"]
    YICES_UPDATE_TERM = 8,
    #[doc = " tuple constructor"]
    YICES_TUPLE_TERM = 9,
    #[doc = " equality"]
    YICES_EQ_TERM = 10,
    #[doc = " distinct t_1 ... t_n"]
    YICES_DISTINCT_TERM = 11,
    #[doc = " quantifier"]
    YICES_FORALL_TERM = 12,
    #[doc = " lambda"]
    YICES_LAMBDA_TERM = 13,
    #[doc = " (not t)"]
    YICES_NOT_TERM = 14,
    #[doc = " n-ary OR"]
    YICES_OR_TERM = 15,
    #[doc = " n-ary XOR"]
    YICES_XOR_TERM = 16,
    #[doc = " array of boolean terms"]
    YICES_BV_ARRAY = 17,
    #[doc = " unsigned division"]
    YICES_BV_DIV = 18,
    #[doc = " unsigned remainder"]
    YICES_BV_REM = 19,
    #[doc = " signed division"]
    YICES_BV_SDIV = 20,
    #[doc = " remainder in signed division (rounding to 0)"]
    YICES_BV_SREM = 21,
    #[doc = " remainder in signed division (rounding to -infinity)"]
    YICES_BV_SMOD = 22,
    #[doc = " shift left (padding with 0)"]
    YICES_BV_SHL = 23,
    #[doc = " logical shift right (padding with 0)"]
    YICES_BV_LSHR = 24,
    #[doc = " arithmetic shift right (padding with sign bit)"]
    YICES_BV_ASHR = 25,
    #[doc = " unsigned comparison: (t1 >= t2)"]
    YICES_BV_GE_ATOM = 26,
    #[doc = " signed comparison (t1 >= t2)"]
    YICES_BV_SGE_ATOM = 27,
    #[doc = " atom (t1 >= t2) for arithmetic terms: t2 is always 0"]
    YICES_ARITH_GE_ATOM = 28,
    #[doc = " atom (0 <= k <= root_count(p)) && (x r root(p, k)) for r in <, <=, ==, !=, >, >="]
    YICES_ARITH_ROOT_ATOM = 29,
    #[doc = " absolute value"]
    YICES_ABS = 30,
    #[doc = " ceil"]
    YICES_CEIL = 31,
    #[doc = " floor"]
    YICES_FLOOR = 32,
    #[doc = " real division (as in x/y)"]
    YICES_RDIV = 33,
    #[doc = " integer division"]
    YICES_IDIV = 34,
    #[doc = " modulo"]
    YICES_IMOD = 35,
    #[doc = " integrality test: (is-int t)"]
    YICES_IS_INT_ATOM = 36,
    #[doc = " divisibility test: (divides t1 t2)"]
    YICES_DIVIDES_ATOM = 37,
    #[doc = " tuple projection"]
    YICES_SELECT_TERM = 38,
    #[doc = " bit-select: extract the i-th bit of a bitvector"]
    YICES_BIT_TERM = 39,
    #[doc = " sum of pairs a * t where a is a bitvector constant (and t is a bitvector term)"]
    YICES_BV_SUM = 40,
    #[doc = " sum of pairs a * t where a is a rational (and t is an arithmetic term)"]
    YICES_ARITH_SUM = 41,
    #[doc = " power products: (t1^d1 * ... * t_n^d_n)"]
    YICES_POWER_PRODUCT = 42,
}
#[repr(u32)]
#[doc = " Tags for the node descriptors"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum yval_tag {
    YVAL_UNKNOWN = 0,
    YVAL_BOOL = 1,
    YVAL_RATIONAL = 2,
    YVAL_ALGEBRAIC = 3,
    YVAL_BV = 4,
    YVAL_SCALAR = 5,
    YVAL_TUPLE = 6,
    YVAL_FUNCTION = 7,
    YVAL_MAPPING = 8,
}
#[repr(u32)]
#[doc = " These codes define a generalization algorithm for functions\n      yices_generalize_model\n and  yices_generalize_model_array\n\n There are currently two algorithms: generalization by\n substitution and generalization by projection.\n The default is to select the algorithm based on variables\n to eliminate."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum yices_gen_mode {
    YICES_GEN_DEFAULT = 0,
    YICES_GEN_BY_SUBST = 1,
    YICES_GEN_BY_PROJ = 2,
}
#[repr(u32)]
#[doc = " Error reports\n - the API function return a default value if there's an error\n   (e.g., term constructors return NULL_TERM, type constructors return NULL_TYPE).\n - details about the cause of the error are stored in an error_report structure\n   defined below.\n - the error report contains an error code and extra information\n   that depends on the error code."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum error_code {
    NO_ERROR = 0,
    #[doc = " Errors in type or term construction"]
    INVALID_TYPE = 1,
    #[doc = " Errors in type or term construction"]
    INVALID_TERM = 2,
    #[doc = " Errors in type or term construction"]
    INVALID_CONSTANT_INDEX = 3,
    #[doc = " Not used anymore"]
    INVALID_VAR_INDEX = 4,
    INVALID_TUPLE_INDEX = 5,
    INVALID_RATIONAL_FORMAT = 6,
    INVALID_FLOAT_FORMAT = 7,
    INVALID_BVBIN_FORMAT = 8,
    INVALID_BVHEX_FORMAT = 9,
    INVALID_BITSHIFT = 10,
    INVALID_BVEXTRACT = 11,
    #[doc = " added 2014/02/17"]
    INVALID_BITEXTRACT = 12,
    TOO_MANY_ARGUMENTS = 13,
    TOO_MANY_VARS = 14,
    MAX_BVSIZE_EXCEEDED = 15,
    DEGREE_OVERFLOW = 16,
    DIVISION_BY_ZERO = 17,
    POS_INT_REQUIRED = 18,
    NONNEG_INT_REQUIRED = 19,
    SCALAR_OR_UTYPE_REQUIRED = 20,
    FUNCTION_REQUIRED = 21,
    TUPLE_REQUIRED = 22,
    VARIABLE_REQUIRED = 23,
    ARITHTERM_REQUIRED = 24,
    BITVECTOR_REQUIRED = 25,
    SCALAR_TERM_REQUIRED = 26,
    WRONG_NUMBER_OF_ARGUMENTS = 27,
    TYPE_MISMATCH = 28,
    INCOMPATIBLE_TYPES = 29,
    DUPLICATE_VARIABLE = 30,
    INCOMPATIBLE_BVSIZES = 31,
    EMPTY_BITVECTOR = 32,
    #[doc = " added 2013/01/23"]
    ARITHCONSTANT_REQUIRED = 33,
    #[doc = " added 2013/03/31"]
    INVALID_MACRO = 34,
    #[doc = " added 2013/03/31"]
    TOO_MANY_MACRO_PARAMS = 35,
    #[doc = " added 2013/03/31"]
    TYPE_VAR_REQUIRED = 36,
    #[doc = " added 2013/03/31"]
    DUPLICATE_TYPE_VAR = 37,
    #[doc = " added 2013/05/27"]
    BVTYPE_REQUIRED = 38,
    #[doc = " added 2013/10/03"]
    BAD_TERM_DECREF = 39,
    #[doc = " added 2013/10/03"]
    BAD_TYPE_DECREF = 40,
    #[doc = " added 2014/12/03"]
    INVALID_TYPE_OP = 41,
    #[doc = " added 2014/12/04"]
    INVALID_TERM_OP = 42,
    #[doc = " Parser errors"]
    INVALID_TOKEN = 100,
    #[doc = " Parser errors"]
    SYNTAX_ERROR = 101,
    #[doc = " Parser errors"]
    UNDEFINED_TYPE_NAME = 102,
    #[doc = " Parser errors"]
    UNDEFINED_TERM_NAME = 103,
    #[doc = " Parser errors"]
    REDEFINED_TYPE_NAME = 104,
    #[doc = " Parser errors"]
    REDEFINED_TERM_NAME = 105,
    #[doc = " Parser errors"]
    DUPLICATE_NAME_IN_SCALAR = 106,
    #[doc = " Parser errors"]
    DUPLICATE_VAR_NAME = 107,
    #[doc = " Parser errors"]
    INTEGER_OVERFLOW = 108,
    #[doc = " Parser errors"]
    INTEGER_REQUIRED = 109,
    #[doc = " Parser errors"]
    RATIONAL_REQUIRED = 110,
    #[doc = " Parser errors"]
    SYMBOL_REQUIRED = 111,
    #[doc = " Parser errors"]
    TYPE_REQUIRED = 112,
    #[doc = " Parser errors"]
    NON_CONSTANT_DIVISOR = 113,
    #[doc = " Parser errors"]
    NEGATIVE_BVSIZE = 114,
    #[doc = " Parser errors"]
    INVALID_BVCONSTANT = 115,
    #[doc = " Parser errors"]
    TYPE_MISMATCH_IN_DEF = 116,
    #[doc = " Parser errors"]
    ARITH_ERROR = 117,
    #[doc = " Parser errors"]
    BVARITH_ERROR = 118,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_FREE_VAR_IN_FORMULA = 300,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_LOGIC_NOT_SUPPORTED = 301,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_UF_NOT_SUPPORTED = 302,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_ARITH_NOT_SUPPORTED = 303,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_BV_NOT_SUPPORTED = 304,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_ARRAYS_NOT_SUPPORTED = 305,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_QUANTIFIERS_NOT_SUPPORTED = 306,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_LAMBDAS_NOT_SUPPORTED = 307,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_NONLINEAR_ARITH_NOT_SUPPORTED = 308,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_FORMULA_NOT_IDL = 309,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_FORMULA_NOT_RDL = 310,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_TOO_MANY_ARITH_VARS = 311,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_TOO_MANY_ARITH_ATOMS = 312,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_TOO_MANY_BV_VARS = 313,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_TOO_MANY_BV_ATOMS = 314,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_ARITH_SOLVER_EXCEPTION = 315,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_BV_SOLVER_EXCEPTION = 316,
    #[doc = " Errors in assertion processing.\n These codes mean that the context, as configured,\n cannot process the assertions."]
    CTX_ARRAY_SOLVER_EXCEPTION = 317,
    #[doc = " added 2015/03/26"]
    CTX_SCALAR_NOT_SUPPORTED = 318,
    #[doc = " added 2015/03/26"]
    CTX_TUPLE_NOT_SUPPORTED = 319,
    #[doc = " added 2015/03/26"]
    CTX_UTYPE_NOT_SUPPORTED = 320,
    #[doc = " added 2021/06/29"]
    CTX_HIGH_ORDER_FUN_NOT_SUPPORTED = 321,
    #[doc = " Error codes for other operations"]
    CTX_INVALID_OPERATION = 400,
    #[doc = " Error codes for other operations"]
    CTX_OPERATION_NOT_SUPPORTED = 401,
    #[doc = " Error codes for delegates\n\n Since 2.6.2."]
    CTX_UNKNOWN_DELEGATE = 420,
    #[doc = " Error codes for delegates\n\n Since 2.6.2."]
    CTX_DELEGATE_NOT_AVAILABLE = 421,
    #[doc = " Error codes for exists/forall solver & quantifiers\n (since 2021/03/01)"]
    CTX_EF_ASSERTIONS_CONTAIN_UF = 440,
    #[doc = " Error codes for exists/forall solver & quantifiers\n (since 2021/03/01)"]
    CTX_EF_NOT_EXISTS_FORALL = 441,
    #[doc = " Error codes for exists/forall solver & quantifiers\n (since 2021/03/01)"]
    CTX_EF_HIGH_ORDER_VARS = 442,
    #[doc = " Error codes for exists/forall solver & quantifiers\n (since 2021/03/01)"]
    CTX_EF_INTERNAL_ERROR = 443,
    #[doc = " Errors in context configurations and search parameter settings"]
    CTX_INVALID_CONFIG = 500,
    #[doc = " Errors in context configurations and search parameter settings"]
    CTX_UNKNOWN_PARAMETER = 501,
    #[doc = " Errors in context configurations and search parameter settings"]
    CTX_INVALID_PARAMETER_VALUE = 502,
    #[doc = " Errors in context configurations and search parameter settings"]
    CTX_UNKNOWN_LOGIC = 503,
    #[doc = " Error codes for model queries"]
    EVAL_UNKNOWN_TERM = 600,
    #[doc = " Error codes for model queries"]
    EVAL_FREEVAR_IN_TERM = 601,
    #[doc = " Error codes for model queries"]
    EVAL_QUANTIFIER = 602,
    #[doc = " Error codes for model queries"]
    EVAL_LAMBDA = 603,
    #[doc = " Error codes for model queries"]
    EVAL_OVERFLOW = 604,
    #[doc = " Error codes for model queries"]
    EVAL_FAILED = 605,
    #[doc = " Error codes for model queries"]
    EVAL_CONVERSION_FAILED = 606,
    #[doc = " Error codes for model queries"]
    EVAL_NO_IMPLICANT = 607,
    #[doc = " Error codes for model queries"]
    EVAL_NOT_SUPPORTED = 608,
    #[doc = " Error codes for model construction"]
    MDL_UNINT_REQUIRED = 700,
    #[doc = " Error codes for model construction"]
    MDL_CONSTANT_REQUIRED = 701,
    #[doc = " Error codes for model construction"]
    MDL_DUPLICATE_VAR = 702,
    #[doc = " Error codes for model construction"]
    MDL_FTYPE_NOT_ALLOWED = 703,
    #[doc = " Error codes for model construction"]
    MDL_CONSTRUCTION_FAILED = 704,
    #[doc = " Error codes for model construction"]
    MDL_NONNEG_INT_REQUIRED = 705,
    #[doc = " Error codes in DAG/node queries"]
    YVAL_INVALID_OP = 800,
    #[doc = " Error codes in DAG/node queries"]
    YVAL_OVERFLOW = 801,
    #[doc = " Error codes in DAG/node queries"]
    YVAL_NOT_SUPPORTED = 802,
    #[doc = " Error codes for model generalization"]
    MDL_GEN_TYPE_NOT_SUPPORTED = 900,
    #[doc = " Error codes for model generalization"]
    MDL_GEN_NONLINEAR = 901,
    #[doc = " Error codes for model generalization"]
    MDL_GEN_FAILED = 902,
    #[doc = " Error codes for model generalization"]
    MDL_GEN_UNSUPPORTED_TERM = 903,
    #[doc = " MCSAT error codes"]
    MCSAT_ERROR_UNSUPPORTED_THEORY = 1000,
    #[doc = " MCSAT error codes"]
    MCSAT_ERROR_ASSUMPTION_TERM_NOT_SUPPORTED = 1001,
    #[doc = " Input/output and system errors"]
    OUTPUT_ERROR = 9000,
    #[doc = " Catch-all code for anything else.\n This is a symptom that a bug has been found."]
    INTERNAL_EXCEPTION = 9999,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t {{ union }}")
    }
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __darwin_arm_vfp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __darwin_mcontext32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __darwin_sigaltstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __darwin_ucontext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for sigval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "sigval {{ union }}")
    }
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for sigevent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "sigevent {{ sigev_notify: {:?}, sigev_signo: {:?}, sigev_value: {:?}, sigev_notify_function: {:?}, sigev_notify_attributes: {:?} }}" , self . sigev_notify , self . sigev_signo , self . sigev_value , self . sigev_notify_function , self . sigev_notify_attributes)
    }
}
impl Default for __siginfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for __siginfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__siginfo {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, si_band: {:?}, __pad: {:?} }}" , self . si_signo , self . si_errno , self . si_code , self . si_pid , self . si_uid , self . si_status , self . si_addr , self . si_value , self . si_band , self . __pad)
    }
}
impl Default for __sigaction_u {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for __sigaction_u {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__sigaction_u {{ union }}")
    }
}
impl Default for __sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for __sigaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "__sigaction {{ __sigaction_u: {:?}, sa_tramp: {:?}, sa_mask: {:?}, sa_flags: {:?} }}",
            self.__sigaction_u, self.sa_tramp, self.sa_mask, self.sa_flags
        )
    }
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for sigaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "sigaction {{ __sigaction_u: {:?}, sa_mask: {:?}, sa_flags: {:?} }}",
            self.__sigaction_u, self.sa_mask, self.sa_flags
        )
    }
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for wait {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for wait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "wait {{ union }}")
    }
}
impl Default for term_vector_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for type_vector_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for yval_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for yval_vector_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for error_report_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for interpolation_context_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Error reports\n - the API function return a default value if there's an error\n   (e.g., term constructors return NULL_TERM, type constructors return NULL_TYPE).\n - details about the cause of the error are stored in an error_report structure\n   defined below.\n - the error report contains an error code and extra information\n   that depends on the error code."]
pub use self::error_code as error_code_t;
#[doc = " Context status code"]
pub use self::smt_status as smt_status_t;
#[doc = " These codes are part of the term exploration API."]
pub use self::term_constructor as term_constructor_t;
#[doc = " These codes define a generalization algorithm for functions\n      yices_generalize_model\n and  yices_generalize_model_array\n\n There are currently two algorithms: generalization by\n substitution and generalization by projection.\n The default is to select the algorithm based on variables\n to eliminate."]
pub use self::yices_gen_mode as yices_gen_mode_t;
#[doc = " Tags for the node descriptors"]
pub use self::yval_tag as yval_tag_t;
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    #[must_use]
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[must_use]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The version as a string \"x.y.z\""]
    pub static mut yices_version: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " More details about the release:\n - build_arch is a string like \"x86_64-unknown-linux-gnu\"\n - build_mode is \"release\" or \"debug\"\n - build_date is the compilation date as in \"2014-01-27\""]
    pub static mut yices_build_arch: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut yices_build_mode: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut yices_build_date: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check whether the library was compiled with MCSAT support (i.e.,\n it can deal with nonlinear arithmetic).\n - return 1 if yes, 0 if no"]
    pub fn yices_has_mcsat() -> i32;
}
extern "C" {
    #[doc = " Check whether the library was compiled in THREAD_SAFE mode.\n - return 1 if yes, 0 if no\n\n Since 2.6.2."]
    pub fn yices_is_thread_safe() -> i32;
}
extern "C" {
    #[doc = " This function must be called before anything else to initialize\n internal data structures."]
    pub fn yices_init();
}
extern "C" {
    #[doc = " Delete all internal data structures and objects\n - this must be called to avoid memory leaks"]
    pub fn yices_exit();
}
extern "C" {
    #[doc = " Full reset\n - delete all terms and types and reset the symbol tables\n - delete all contexts, models, configuration descriptors and\n   parameter records."]
    pub fn yices_reset();
}
extern "C" {
    #[doc = " Delete a string returned by yices\n\n Several functions construct and return a string:\n - yices_error_string\n - yices_type_to_string\n - yices_term_to_string\n - yices_model_to_string\n\n The returned string must be freed when it's no longer used by\n calling this function."]
    pub fn yices_free_string(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " By default, when Yices runs out of memory, it\n first prints an error message on stderr; then it calls\n exit(YICES_EXIT_OUT_OF_MEMORY).  This kills the whole process.\n\n The following function allows you to register a callback to invoke\n if Yices runs out of memory.  The callback function takes no\n arguments and returns nothing.\n\n Installing an out-of-memory callback allows you to do something a\n bit less brutal than killing the process. If there's a callback,\n yices will call it first when it runs out of memory.  The callback\n function should not return. If it does, yices will call exit as\n previously.\n\n In other words, the code that handles out-of-memory is as follows:\n\n   if (callback != NULL) {\n     callback();\n   } else {\n     fprintf(stderr, ...);\n   }\n   exit(YICES_EXIT_OUT_OF_MEMORY);\n\n\n IMPORTANT\n ---------\n After Yices runs out of memory, its internal data structures may be\n left in an inconsistent/corrupted state. The API is effectively\n unusable at this point and nothing can be done to recover cleanly.\n Evan a call to yices_exit() may cause a seg fault. The callback\n should not try to cleanup anything, or call any function from the API.\n\n A plausible use of this callback feature is to implement an\n exception mechanism using setjmp/longjmp."]
    pub fn yices_set_out_of_mem_callback(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " Get the last error code"]
    pub fn yices_error_code() -> error_code_t;
}
extern "C" {
    #[doc = " Get the last error report"]
    pub fn yices_error_report() -> *mut error_report_t;
}
extern "C" {
    #[doc = " Clear the error report"]
    pub fn yices_clear_error();
}
extern "C" {
    #[doc = " Print an error message on stream f.  This converts the current error\n code + error report structure into an error message.\n - f must be a non-NULL open stream (writable)\n\n Return -1 if there's an error while writing to f (as reported by fprintf).\n Return 0 otherwise.\n\n If there's an error, errno, perror, and friends can be used for diagnostic."]
    pub fn yices_print_error(f: *mut FILE) -> i32;
}
extern "C" {
    #[doc = " Print an error message on file descriptor fd.  This converts the current error\n code + error report structure into an error message.\n - fd must be an open file descriptor (writable)\n\n Return -1 if there's an error while writing to fd.\n Return 0 otherwise.\n\n If there's an error, errno, perror, and friends can be used for diagnostic."]
    pub fn yices_print_error_fd(fd: ::std::os::raw::c_int) -> i32;
}
extern "C" {
    #[doc = " Build a string from the current error code + error report structure.\n\n The returned string must be freed when no-longer used by calling\n yices_free_string."]
    pub fn yices_error_string() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize a term or type vector v"]
    pub fn yices_init_term_vector(v: *mut term_vector_t);
}
extern "C" {
    pub fn yices_init_type_vector(v: *mut type_vector_t);
}
extern "C" {
    #[doc = " Delete vector v"]
    pub fn yices_delete_term_vector(v: *mut term_vector_t);
}
extern "C" {
    pub fn yices_delete_type_vector(v: *mut type_vector_t);
}
extern "C" {
    #[doc = " Reset: empty the vector (reset size to 0)"]
    pub fn yices_reset_term_vector(v: *mut term_vector_t);
}
extern "C" {
    pub fn yices_reset_type_vector(v: *mut type_vector_t);
}
extern "C" {
    #[doc = " Built-in types bool, int, real."]
    pub fn yices_bool_type() -> type_t;
}
extern "C" {
    pub fn yices_int_type() -> type_t;
}
extern "C" {
    pub fn yices_real_type() -> type_t;
}
extern "C" {
    #[doc = " Bitvectors of given size (number of bits)\n Requires size > 0\n\n If size = 0, the error report is set\n   code = POS_INT_REQUIRED\n   badval = size\n If size > YICES_MAX_BVSIZE\n   code = MAX_BVSIZE_EXCEEDED\n   badval = size"]
    pub fn yices_bv_type(size: u32) -> type_t;
}
extern "C" {
    #[doc = " New scalar type of given cardinality.\n Requires card > 0\n\n If card = 0, set error report to\n   code = POS_INT_REQUIRED\n   badval = size"]
    pub fn yices_new_scalar_type(card: u32) -> type_t;
}
extern "C" {
    #[doc = " New uninterpreted type. No error report."]
    pub fn yices_new_uninterpreted_type() -> type_t;
}
extern "C" {
    #[doc = " Tuple type tau[0] x ... x tau[n-1].\n Requires n>0 and tau[0] ... tau[n-1] to be well defined types.\n\n Error report\n if n == 0,\n   code = POS_INT_REQUIRED\n   badval = n\n if n > YICES_MAX_ARITY\n   code = TOO_MANY_ARGUMENTS\n   badval = n\n if tau[i] is not well defined (and tau[0] .. tau[i-1] are)\n   code = INVALID_TYPE\n   type1 = tau[i]"]
    pub fn yices_tuple_type(n: u32, tau: *const type_t) -> type_t;
}
extern "C" {
    #[doc = " Variants: for small arity\n\n These variants build types:\n   (tuple tau1)\n   (tuple tau1 tau2)\n   (tuple tau1 tau2 tau3)\n\n Error report: same as yices_tuple_type if one of the type is invalid"]
    pub fn yices_tuple_type1(tau1: type_t) -> type_t;
}
extern "C" {
    pub fn yices_tuple_type2(tau1: type_t, tau2: type_t) -> type_t;
}
extern "C" {
    pub fn yices_tuple_type3(tau1: type_t, tau2: type_t, tau3: type_t) -> type_t;
}
extern "C" {
    #[doc = " Function type: dom[0] ... dom[n-1] -> range\n Requires n>0, and dom[0] ... dom[n-1] and range to be well defined\n\n Error report\n if n == 0,\n   code = POS_INT_REQUIRED\n   badval = n\n if n > YICES_MAX_ARITY\n   code = TOO_MANY_ARGUMENTS\n   badval = n\n if range undefined\n   code = INVALID_TYPE\n   type1 = range\n if dom[i] is undefined (and dom[0] ... dom[i-1] are)\n   code = INVALID_TYPE\n   type1 = dom[i]"]
    pub fn yices_function_type(n: u32, dom: *const type_t, range: type_t) -> type_t;
}
extern "C" {
    #[doc = " Variants for small arity:\n   [tau1 -> range]\n   [tau1, tau2 -> range]\n   [tau1, tau2. tau3 -> range]\n\n Same error reports are yices_function_type if one of the type is invalid"]
    pub fn yices_function_type1(tau1: type_t, range: type_t) -> type_t;
}
extern "C" {
    pub fn yices_function_type2(tau1: type_t, tau2: type_t, range: type_t) -> type_t;
}
extern "C" {
    pub fn yices_function_type3(tau1: type_t, tau2: type_t, tau3: type_t, range: type_t) -> type_t;
}
extern "C" {
    #[doc = " Checks on a type tau:\n - all functions return 0 for false, 1 for true\n\n yices_type_is_arithmetic(tau) returns true if tau is either int or real.\n\n if tau not a valid type, the functions return false\n and set the error report:\n   code = INVALID_TYPE\n   type1 = tau"]
    pub fn yices_type_is_bool(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_int(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_real(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_arithmetic(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_bitvector(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_tuple(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_function(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_scalar(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_type_is_uninterpreted(tau: type_t) -> i32;
}
extern "C" {
    #[doc = " Check whether tau is a subtype of sigma\n - returns 0 for false, 1 for true\n\n If tau or sigma is not a valid type, the function returns false\n and sets the error report:\n   code = INVALID_TYPE\n   type1 = tau or sigma"]
    pub fn yices_test_subtype(tau: type_t, sigma: type_t) -> i32;
}
extern "C" {
    #[doc = " Check whether tau and sigma are compatible\n - return 0 for false, 1 for true\n\n If tau or sigma is not a valid type, the function returns 0 and\n sets the error report:\n   code = INVALID_TYPE\n   type1 = tau or sigma"]
    pub fn yices_compatible_types(tau: type_t, sigma: type_t) -> i32;
}
extern "C" {
    #[doc = " Number of bits for type tau\n - returns 0 if there's an error\n\n Error report:\n if tau is not a valid type\n    code = INVALID_TYPE\n    type1 = tau\n if tau is not a bitvector type\n    code = BVTYPE_REQUIRED\n    type1 = tau"]
    pub fn yices_bvtype_size(tau: type_t) -> u32;
}
extern "C" {
    #[doc = " Cardinality of a scalar type\n - returns 0 if there's an error\n\n Error report:\n if tau is not a valid type\n   code = INVALID_TYPE\n   type1 = tau\n if tau is not a scalar type\n   code = INVALID_TYPE_OP"]
    pub fn yices_scalar_type_card(tau: type_t) -> u32;
}
extern "C" {
    #[doc = " Number of children of type tau\n - if tau is a tuple type (tuple tau_1 ... tau_n), returns n\n - if tau is a function type (-> tau_1 ... tau_n sigma), returns n+1\n - if tau is any other type, returns 0\n\n - returns -1 if tau is not a valid type\n\n Error report:\n if tau is not a valid type\n   code = INVALID_TYPE\n   type1 = tau"]
    pub fn yices_type_num_children(tau: type_t) -> i32;
}
extern "C" {
    #[doc = " i-th child of type tau.\n - i must be in 0 and n-1 where n = yices_type_num_children(tau)\n - returns NULL_TYPE if there's an error\n\n For a function type (-> tau_1 ... tau_n sigma), the first n\n children are tau_1 ... tau_n (indexed from 0 to n-1) and the last\n child is sigma (with index i=n).\n\n Error report:\n if tau is not a valid type\n   code = INVALID_TYPE\n   type1 = tau\n if is is negative or larger than n\n   code = INVALID_TYPE_OP"]
    pub fn yices_type_child(tau: type_t, i: i32) -> type_t;
}
extern "C" {
    #[doc = " Collect all the children of type tau in vector *v\n - v must be initialized by calling yices_init_type_vector\n - if tau is not valid, the function returns -1 and leaves *v unchanged\n - otherwise, the children are stored in *v:\n    v->size = number of children\n    v->data[0 ... v->size-1] = the children\n\n The children are stored in the same order as given by yices_type_child:\n    v->data[i] = child of index i.\n\n Error report:\n if tau is not a valid type\n   code = INVALID_TYPE\n   type1 = tau"]
    pub fn yices_type_children(tau: type_t, v: *mut type_vector_t) -> i32;
}
extern "C" {
    #[doc = " Boolean constants: no error report"]
    pub fn yices_true() -> term_t;
}
extern "C" {
    pub fn yices_false() -> term_t;
}
extern "C" {
    #[doc = " Constant of type tau and id = index\n - tau must be a scalar type or an uninterpreted type\n - index must be non-negative, and, if tau is scalar,\n   index must be less than tau's cardinality.\n\n Each constant is identified by its index. Two constants\n of type tau that have different indices are distinct.\n\n Error report:\n if tau is undefined\n   code = INVALID_TYPE\n   type1 = tau\n if tau is not scalar or uninterpreted,\n   code = SCALAR_OR_UTYPE_REQUIRED\n   type1 = tau\n if the index is negative or too large\n   code = INVALID_CONSTANT_INDEX\n   type1 = tau\n   badval = index"]
    pub fn yices_constant(tau: type_t, index: i32) -> term_t;
}
extern "C" {
    #[doc = " Uninterpreted term of type tau\n\n An uninterpreted term is like a global variable of type tau. But, we\n don't call it a variable, because variables have a different meaning\n in Yices (see next function).\n\n If tau is a function type, then this creates an uninterpreted\n function (see yices_application).\n\n Error report:\n if tau is undefined\n   code = INVALID_TYPE\n   type1 = tau"]
    pub fn yices_new_uninterpreted_term(tau: type_t) -> term_t;
}
extern "C" {
    #[doc = " Variable of type tau. This creates a new variable.\n\n Variables are different form uninterpreted terms. They are used\n in quantifiers and to support substitutions.\n\n Error report:\n if tau is undefined\n   code = INVALID_TYPE\n   type1 = tau"]
    pub fn yices_new_variable(tau: type_t) -> term_t;
}
extern "C" {
    #[doc = " Application of an uninterpreted function to n arguments.\n\n Error report:\n if n == 0,\n   code = POS_INT_REQUIRED\n   badval = n\n if fun or arg[i] is not defined\n   code = INVALID_TERM\n   term1 = fun or arg[i]\n if fun is not a function\n   code = FUNCTION_REQUIRED\n   term1 = fun\n if n != number of arguments required for fun\n   code = WRONG_NUMBER_OF_ARGUMENTS\n   type1 = type of fun\n   badval = n\n if arg[i] has a wrong type\n   code = TYPE_MISMATCH\n   term1 = arg[i]\n   type1 = expected type"]
    pub fn yices_application(fun: term_t, n: u32, arg: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Variants for small arity:\n - the arguments are given as arg1, arg2, arg3 instead of an array of n terms\n - fun must be an uninterpreted function of arity 1, 2, or 3\n\n Same error reports are yices_application"]
    pub fn yices_application1(fun: term_t, arg1: term_t) -> term_t;
}
extern "C" {
    pub fn yices_application2(fun: term_t, arg1: term_t, arg2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_application3(fun: term_t, arg1: term_t, arg2: term_t, arg3: term_t) -> term_t;
}
extern "C" {
    #[doc = " if-then-else\n\n Error report:\n if cond, then_term, or else_term is not a valid term\n   code = INVALID_TERM\n   term1 = whichever of cond, then_term, or else_term is invalid\n if cond is not boolean\n   code = TYPE_MISMATCH\n   term1 = cond\n   type1 = bool (expected type)\n if then_term and else_term have incompatible types\n   code = INCOMPATIBLE_TYPES\n   term1 = then_term\n   type1 = term1's type\n   term2 = else_term\n   type2 = term2's type"]
    pub fn yices_ite(cond: term_t, then_term: term_t, else_term: term_t) -> term_t;
}
extern "C" {
    #[doc = " Equality (= left right)\n Disequality (/= left right)\n\n Error report:\n if left or right is not a valid term\n   code = INVALID_TERM\n   term1 = left or right\n if left and right do not have compatible types\n   code = INCOMPATIBLE_TYPES\n   term1 = left\n   type1 = term1's type\n   term2 = right\n   type2 = term2's type"]
    pub fn yices_eq(left: term_t, right: term_t) -> term_t;
}
extern "C" {
    pub fn yices_neq(left: term_t, right: term_t) -> term_t;
}
extern "C" {
    #[doc = " (not arg)\n\n Error report:\n if arg is invalid\n    code = INVALID_TERM\n    term1 = arg\n if arg is not boolean\n    code = TYPE_MISMATCH\n    term1 = arg\n    type1 = bool (expected type)"]
    pub fn yices_not(arg: term_t) -> term_t;
}
extern "C" {
    #[doc = " (or  arg[0] ... arg[n-1])\n (and arg[0] ... arg[n-1])\n (xor arg[0] ... arg[n-1])\n\n NOTE: ARRAY ARG MAY BE MODIFIED.\n\n Error report:\n if n > YICES_MAX_ARITY\n   code = TOO_MANY_ARGUMENTS\n   badval = n\n if arg[i] is not a valid term\n   code = INVALID_TERM\n   term1 = arg[i]\n if arg[i] is not boolean\n   code = TYPE_MISMATCH\n   term1 = arg[i]\n   type1 = bool (expected type)"]
    pub fn yices_or(n: u32, arg: *mut term_t) -> term_t;
}
extern "C" {
    pub fn yices_and(n: u32, arg: *mut term_t) -> term_t;
}
extern "C" {
    pub fn yices_xor(n: u32, arg: *mut term_t) -> term_t;
}
extern "C" {
    #[doc = " Variants of or/and/xor with 2 or 3 arguments"]
    pub fn yices_or2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_and2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_xor2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_or3(t1: term_t, t2: term_t, t3: term_t) -> term_t;
}
extern "C" {
    pub fn yices_and3(t1: term_t, t2: term_t, t3: term_t) -> term_t;
}
extern "C" {
    pub fn yices_xor3(t1: term_t, t2: term_t, t3: term_t) -> term_t;
}
extern "C" {
    #[doc = " (iff left right)\n (implies left right)\n\n Error report:\n if left or right is invalid\n    code = INVALID_TERM\n    term1 = left/right\n if left or right is not boolean\n    code = TYPE_MISMATCH\n    term1 = left/right\n    type1 = bool (expected type)"]
    pub fn yices_iff(left: term_t, right: term_t) -> term_t;
}
extern "C" {
    pub fn yices_implies(left: term_t, right: term_t) -> term_t;
}
extern "C" {
    #[doc = " Tuple constructor\n\n Error report:\n if n == 0\n   code = POS_INT_REQUIRED\n   badval = n\n if n > YICES_MAX_ARITY\n   code = TOO_MANY_ARGUMENTS\n   badval = n\n if one arg[i] is invalid\n   code = INVALID_TERM\n   term1 = arg[i]"]
    pub fn yices_tuple(n: u32, arg: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Variants for n=2 or n=3\n - same error reports as yices_tuple if arg1, arg2, or arg3 is invalid"]
    pub fn yices_pair(arg1: term_t, arg2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_triple(arg1: term_t, arg2: term_t, arg3: term_t) -> term_t;
}
extern "C" {
    #[doc = " Tuple projection\n\n The index must be between 1 and n (where n = number of components in tuple)\n\n Error report:\n if tuple is invalid\n    code = INVALID_TERM\n    term1 = tuple\n if tuple does not have a tuple type\n    code = TUPLE_REQUIRED\n    term1 = tuple\n if index = 0 or index > number of components in tuple\n    code = INVALID_TUPLE_INDEX\n    type1 = type of tuple\n    badval = index"]
    pub fn yices_select(index: u32, tuple: term_t) -> term_t;
}
extern "C" {
    #[doc = " Tuple update: replace component i of tuple by new_v\n\n The index must be between 1 and n (where n = number of components in tuple)\n\n Error report\n if tuple or new_v is invalid\n    code = INVALID_TERM\n    term1 = tuple/new_v\n if tuple doesn't have a tuple type\n    code = TUPLE_REQUIRED\n    term1 = tuple\n if index = 0 or index > number of components in tuple\n    code = INVALID_TUPLE_INDEX\n    type1 = tuple's type\n    badval = index\n if new_v has a wrong type\n    code = TYPE_MISMATCH\n    term1 = new_v\n    type1 = expected type (i-th component type in tuple)"]
    pub fn yices_tuple_update(tuple: term_t, index: u32, new_v: term_t) -> term_t;
}
extern "C" {
    #[doc = " Function update\n\n Error report:\n if n = 0\n    code = POS_INT_REQUIRED\n    badval = n\n if fun or new_v, or one of arg[i] is invalid\n    code = INVALID_TERM\n    term1 = fun, new_v, or arg[i]\n if fun does not have a function type\n    code = FUNCTION_REQUIRED\n    term1 = fun\n if n != number of arguments for fun\n    code = WRONG_NUMBER_OF_ARGUMENTS\n    type1 = type of fun\n    badval = n\n if new_v has a wrong type (not a subtype of fun's range)\n    code = TYPE_MISMATCH\n    term1 = new_v\n    type1 = fun's range (expected type)\n if arg[i] has a wrong type for i-th arg of fun\n    code = TYPE_MISMATCH\n    term1 = arg[i]\n    type1 = expected type"]
    pub fn yices_update(fun: term_t, n: u32, arg: *const term_t, new_v: term_t) -> term_t;
}
extern "C" {
    #[doc = " Variants of yices_update for small n\n - fun must be a function of arity 1, 2, or 3\n - the arguments are given as arg1, arg2, arg3 instead of an array arg[]"]
    pub fn yices_update1(fun: term_t, arg1: term_t, new_v: term_t) -> term_t;
}
extern "C" {
    pub fn yices_update2(fun: term_t, arg1: term_t, arg2: term_t, new_v: term_t) -> term_t;
}
extern "C" {
    pub fn yices_update3(
        fun: term_t,
        arg1: term_t,
        arg2: term_t,
        arg3: term_t,
        new_v: term_t,
    ) -> term_t;
}
extern "C" {
    #[doc = " Distinct\n\n NOTE: ARG MANY BE MODIFIED\n\n Error report:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_ARITY\n    code = TOO_MANY_ARGUMENTS\n    badval = n\n if arg[i] is not a valid term\n    code = INVALID_TERM\n    term1 = arg[i]\n if two terms arg[i] and arg[j] don't have compatible types\n    code = INCOMPATIBLE_TYPES\n    term1 = arg[i]\n    type1 = term1's type\n    term2 = arg[j]\n    type2 = term2's type"]
    pub fn yices_distinct(n: u32, arg: *mut term_t) -> term_t;
}
extern "C" {
    #[doc = " Quantified terms\n  (forall (var[0] ... var[n-1]) body)\n  (exists (var[0] ... var[n-1]) body)\n\n NOTE: ARRAY VAR MAY BE MODIFIED\n\n Error report:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_VARS\n    code = TOO_MANY_VARS\n    badval = n\n if body or one of var[i] is invalid\n    code = INVALID_TERM\n    term1 = body or var[i]\n if body is not boolean\n    code = TYPE_MISMATCH\n    term1 = body\n    type1 = bool (expected type)\n if one of var[i] is not a variable\n    code = VARIABLE_REQUIRED\n    term1 = var[i]\n if one variable occurs twice in var\n    code = DUPLICATE_VARIABLE\n    term1 = var[i]"]
    pub fn yices_forall(n: u32, var: *mut term_t, body: term_t) -> term_t;
}
extern "C" {
    pub fn yices_exists(n: u32, var: *mut term_t, body: term_t) -> term_t;
}
extern "C" {
    #[doc = " Lambda terms\n\n Error report:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_VARS\n    code = TOO_MANY_VARS\n    badval = n\n if body or one of var[i] is invalid\n    code = INVALID_TERM\n    term1 = body or var[i]\n if one of var[i] is not a variable\n    code = VARIABLE_REQUIRED\n    term1 = var[i]\n if one variable occurs twice in var\n    code = DUPLICATE_VARIABLE\n    term1 = var[i]\n"]
    pub fn yices_lambda(n: u32, var: *const term_t, body: term_t) -> term_t;
}
extern "C" {
    #[doc = " Zero: no error"]
    pub fn yices_zero() -> term_t;
}
extern "C" {
    #[doc = " Integer constants"]
    pub fn yices_int32(val: i32) -> term_t;
}
extern "C" {
    pub fn yices_int64(val: i64) -> term_t;
}
extern "C" {
    #[doc = " Rational constants\n - den must be non-zero\n - common factors are removed\n\n Error report:\n if den is zero\n   code = DIVISION_BY_ZERO"]
    pub fn yices_rational32(num: i32, den: u32) -> term_t;
}
extern "C" {
    pub fn yices_rational64(num: i64, den: u64) -> term_t;
}
extern "C" {
    #[doc = " Convert a string to a rational or integer term.\n The string format is\n     <optional_sign> <numerator>/<denominator>\n  or <optional_sign> <numerator>\n\n where <optional_sign> is + or - or nothing\n <numerator> and <denominator> are sequences of\n decimal digits.\n\n Error report:\n   code = INVALID_RATIONAL_FORMAT if s is not in this format\n   code = DIVISION_BY_ZERO if the denominator is zero"]
    pub fn yices_parse_rational(s: *const ::std::os::raw::c_char) -> term_t;
}
extern "C" {
    #[doc = " Convert a string in floating point format to a rational\n The string must be in one of the following formats:\n   <optional sign> <integer part> . <fractional part>\n   <optional sign> <integer part> <exp> <optional sign> <integer>\n   <optional sign> <integer part> . <fractional part> <exp> <optional sign> <integer>\n\n where <optional sign> is + or - or nothing\n       <exp> is either 'e' or 'E'\n\n Error report:\n code = INVALID_FLOAT_FORMAT"]
    pub fn yices_parse_float(s: *const ::std::os::raw::c_char) -> term_t;
}
extern "C" {
    #[doc = " All operations return NULL_TERM if there's an error (NULL_TERM = -1)\n\n Error reports:\n if t1 or t2 is not valid\n   code = INVALID_TERM\n   term1 = t1 or t2\n if t1 or t2 is not an arithmetic term\n   code = ARITHTERM_REQUIRED\n   term1 = t1 or t2\n\n for yices_mul, yices_square, and yices_power,\n if the result's degree is too large,\n then the error report is\n   code = DEGREE_OVERFLOW\n   badval = product degree"]
    pub fn yices_add(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_sub(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_neg(t1: term_t) -> term_t;
}
extern "C" {
    pub fn yices_mul(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_square(t1: term_t) -> term_t;
}
extern "C" {
    pub fn yices_power(t1: term_t, d: u32) -> term_t;
}
extern "C" {
    #[doc = " Sum of n arithmetic terms t[0] ... t[n-1]\n\n Return NULL_TERM if there's an error\n\n Error reports:\n if t[i] is not valid\n   code = INVALID_TERM\n   term1 = t[i]\n if t[i] is not an arithmetic term\n   code = ARITHTERM_REQUIRED\n   term1 = t[i]"]
    pub fn yices_sum(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Product of n arithmetic terms t[0] ... t[n-1]\n\n Return NULL_TERM if there's an error\n\n Error reports:\n if t[i] is not valid\n   code = INVALID_TERM\n   term1 = t[i]\n if t[i] is not an arithmetic term\n   code = ARITHTERM_REQUIRED\n   term1 = t[i]\n if the result has degree > YICES_MAX_DEGREE\n   code = DEGREE OVERFLOW\n   badval = degree"]
    pub fn yices_product(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Division:  t1/t2\n\n t1 and t2 must be arithmetic terms\n\n NOTE: Until Yices 2.5.0, t2 was required to be a non-zero constant.\n This is no longer the case: t2 can be any arithmetic term.\n\n Return NULL_TERM if there's an error\n\n Error report:\n if t1 or t2 is not valid\n    code = INVALID_TERM\n    term1 = t1 or t2\n if t1 or t2 is not an arithmetic term\n    code = ARITHTERM_REQUIRED\n    term1 = t1 or t2"]
    pub fn yices_division(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Integer division and modulo\n\n t1 and t2 must arithmetic terms\n\n The semantics is as defined in SMT-LIB 2.0 (theory Ints),\n except that t1 and t2 are not required to be integer.\n\n NOTE: Until Yices 2.5.0, t2 was required to be a non-zero constant.\n This is no longer the case: t2 can be any arithmetic term.\n\n The functions (div t1 t2) and (mod t1 t2) satisfy the following\n constraints:\n    t1 = (div t1 t2) * t2 + (mod t1 t2)\n    0 <= (mod t1 t2) < (abs t2)\n    (div t1 t2) is an integer\n\n The functions return NULL_TERM if there's an error.\n\n Error report:\n if t1 or t2 is not valid\n    code = INVALID_TERM\n    term1 = t1 or t2\n if t1 or t2 is not an arithmetic term\n    code = ARITHTERM_REQUIRED\n    term1 = t1 or t2"]
    pub fn yices_idiv(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_imod(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Divisibility test:\n\n t1 must be an arihtmetic constant.\n t2 must be an arithmetic term.\n\n This function constructs the atom (divides t1 t2).\n The semantics is\n   (divides t1 t2) IFF (there is an integer k such that t2 = k * t1)\n\n The functions return NULL_TERM if there's an error.\n\n Error report:\n if t1 or t2 is not valid\n    code = INVALID_TERM\n    term1 = t1 or t2\n if t1 is not an arithmetic term\n    code = ARITHTERM_REQUIRED\n    term1 = t1\n if t2 is not an arithmetic constant\n    code = ARITHCONSTANT_REQUIRED\n    term1 = t2"]
    pub fn yices_divides_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Integrality test:\n\n t must be an arithmetic term.\n\n This function constructs the atom (is-int t) as defined in\n SMT-LIB 2: (is-int t) is true iff t is an integer. Also, we have\n (is-int t) iff (divides 1 t).\n\n The function returns NULL_TERM if there's an error.\n\n Error report:\n if t is not valid\n    code = INVALID_TERM\n    term1 = t\n if t is not an arithmetic term\n    code = ARITHTERM_REQUIRED\n    term1 = t\n"]
    pub fn yices_is_int_atom(t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Absolute value, floor, ceiling\n\n t must be an arithmetic term\n\n floor t is the largest integer that's less than or equal to t\n ceiling t is the smallest integer that's greater than or equal to t\n The functions return NULL_TERM if there's an error.\n\n Error report:\n if t is not valid\n    code = INVALID_TERM\n    term1 = t\n if t is not an arithmetic term\n    code = ARITHTERM_REQUIRED\n    term1 = t"]
    pub fn yices_abs(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_floor(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_ceil(t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Polynomial with integer coefficients\n - a and t must both be arrays of size n"]
    pub fn yices_poly_int32(n: u32, a: *const i32, t: *const term_t) -> term_t;
}
extern "C" {
    pub fn yices_poly_int64(n: u32, a: *const i64, t: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Polynomial with rational coefficients\n - den, num, and t must be arrays of size n\n - the coefficient a_i is num[i]/den[i]\n\n Error report:\n if den[i] is 0\n   code = DIVISION_BY_ZERO"]
    pub fn yices_poly_rational32(
        n: u32,
        num: *const i32,
        den: *const u32,
        t: *const term_t,
    ) -> term_t;
}
extern "C" {
    pub fn yices_poly_rational64(
        n: u32,
        num: *const i64,
        den: *const u64,
        t: *const term_t,
    ) -> term_t;
}
extern "C" {
    #[doc = " All operations return NULL_TERM if there's an error (NULL_TERM = -1)\n\n Error reports\n if t1 or t2 is not valid\n   code = INVALID_TERM\n   term1 = t1 or t2\n if t1 or t2 is not an arithmetic term\n   code = ARITHTERM_REQUIRED\n   term1 = t1 or t2"]
    pub fn yices_arith_eq_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_neq_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_geq_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_leq_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_gt_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_lt_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Comparison with 0:\n\n Return NULL_TERM if there's an error.\n\n Error report:\n if t is not valid:\n   code = INVALID_TERM\n   term1 = t\n if t is not an arithmetic term\n   code = ARITH_TERM_REQUIRED\n   term1 = t"]
    pub fn yices_arith_eq0_atom(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_neq0_atom(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_geq0_atom(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_leq0_atom(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_gt0_atom(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_arith_lt0_atom(t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Conversion of an integer to a bitvector constant.\n - n = number of bits\n - x = value\n The low-order bit of x is bit 0 of the constant.\n\n For yices_bvconst_uint32:\n - if n is less than 32, then the value of x is truncated to\n   n bits (i.e., only the n least significant bits of x are considered)\n - if n is more than 32, then the value of x is zero-extended to\n   n bits.\n\n For yices_bvconst_uint64:\n - if n is less than 64, then the value of x is truncated to\n   n bits (i.e., only the n least significant bits of x are considered)\n - if n is more than 64, then the value of x is zero-extended to\n   n bits.\n\n For yices_bvconst_int32:\n - if n is less than 32, then the value of x is truncated to\n   n bits (i.e., only the n least significant bits of x are considered)\n - if n is more than 32, then the value of x is sign-extended to\n   n bits.\n\n For yices_bvconst_int64:\n - if n is less than 64, then the value of x is truncated to\n   n bits (i.e., only the n least significant bits of x are considered)\n - if n is more than 64, then the value of x is sign-extended to\n   n bits.\n\n For yices_bvconst_mpz:\n - x is interpreted as a signed number in 2-s complement\n - if x has fewer than n bits (in 2's complement), then the value is sign-extended\n - if x has more than n bits (in 2's complement) then the value is truncated\n   (to n least significant bits).\n\n Error report:\n if n = 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_BVSIZE\n    code = MAX_BVSIZE_EXCEEDED\n    badval = n"]
    pub fn yices_bvconst_uint32(n: u32, x: u32) -> term_t;
}
extern "C" {
    pub fn yices_bvconst_uint64(n: u32, x: u64) -> term_t;
}
extern "C" {
    pub fn yices_bvconst_int32(n: u32, x: i32) -> term_t;
}
extern "C" {
    pub fn yices_bvconst_int64(n: u32, x: i64) -> term_t;
}
extern "C" {
    #[doc = " bvconst_zero: set all bits to 0\n bvconst_one: set low-order bit to 1, all the other bits to 0\n bvconst_minus_one: set all bits to 1\n\n Error report:\n if n = 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_BVSIZE\n    code = MAX_BVSIZE_EXCEEDED\n    badval = n"]
    pub fn yices_bvconst_zero(n: u32) -> term_t;
}
extern "C" {
    pub fn yices_bvconst_one(n: u32) -> term_t;
}
extern "C" {
    pub fn yices_bvconst_minus_one(n: u32) -> term_t;
}
extern "C" {
    #[doc = " Construction from an integer array\n bit i of the constant is 0 if a[i] == 0\n bit i of the constant is 1 if a[i] != 0\n\n The input is interpreted little-endian:\n a[0] = low-order bit (least significant)\n a[n-1] = high-order bit (most significant)\n\n Error report:\n if n = 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_BVSIZE\n    code = MAX_BVSIZE_EXCEEDED\n    badval = n"]
    pub fn yices_bvconst_from_array(n: u32, a: *const i32) -> term_t;
}
extern "C" {
    #[doc = " Parsing from a string of characters '0' and '1'\n First character = high-order bit\n Last character = low-order bit\n The constant has n bits if the strings has n characters.\n\n Error report:\n if the format is incorrect:\n   code = INVALID_BVBIN_FORMAT\n if the string has more than YICES_MAX_BVSIZE digits\n   code = MAX_BVSIZE_EXCEEDED\n   badval = n"]
    pub fn yices_parse_bvbin(s: *const ::std::os::raw::c_char) -> term_t;
}
extern "C" {
    #[doc = " Parsing from a hexadecimal string\n All characters must be '0' to '9' or 'a' to 'f' or 'A' to 'F'\n - First character = 4 high-order bits\n - Last character = 4 low-order bits\n The constant has 4n bits if s has n characters.\n\n Error report:\n if the format is incorrect:\n   code = INVALID_BVHEX_FORMAT\n if the result would have more than YICES_MAX_BVSIZE digits\n   code = MAX_BVSIZE_EXCEEDED\n   badval = 4n"]
    pub fn yices_parse_bvhex(s: *const ::std::os::raw::c_char) -> term_t;
}
extern "C" {
    #[doc = " Binary operations: both arguments must be bitvector terms of the same size.\n The functions return NULL_TERM (-1) if there's an error.\n\n Error reports\n if t1 or t2 is not valid\n   code = INVALID_TERM\n   term1 = t1 or t2\n if t1 or t2 is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t1 or t2\n if t1 and t2 do not have the same bitvector type\n   code = INCOMPATIBLE_TYPES\n   term1 = t1\n   type1 = type of t1\n   term2 = t2\n   type2 = type of t2\n\n For bvmul, bvsquare, or bvpower, if the degree is too large\n   code = DEGREE_OVERFLOW\n\n\n In case of division by 0, Yices uses the following conventions:\n\n   (bvdiv  x 0b00...0) is the  largest unsigned integer that can be represented using n bits\n                       (i.e., 0b111....1)\n\n   (bvrem  x 0b00...0) is x\n\n   (bvsdiv x 0b00...0) is   0b00..01 (i.e., +1) if x's sign bit is 1\n                       and  0b111111 (i.e., -1) if x's sign bit is 0\n\n   (bvsrem x 0b00...0) is x\n\n   (bvsmod x 0b00...0) is x\n"]
    pub fn yices_bvadd(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsub(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvneg(t1: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvmul(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsquare(t1: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvpower(t1: term_t, d: u32) -> term_t;
}
extern "C" {
    pub fn yices_bvdiv(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvrem(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsdiv(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsrem(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsmod(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvnot(t1: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvnand(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvnor(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvxnor(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvshl(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvlshr(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvashr(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Bitvector and/or/xor\n\n The general form takes an array t[0 ...n-1] as argument (n must be positive).\n - all t[i]s must be bitvector term of the same type (i.e., the same number of bits).\n - special forms are provided for convenience for n=2 and 3.\n\n These function return NULL_TERM if there's an error.\n\n Error reports:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if t[i] is not valid\n    code = INVALID_TERM\n    term1 = t[i]\n if t[i] is not a bitvector term\n    code = BITVECTOR_REQUIRED\n    badval = n\n if t[0] and t[i] don't have the same bitvector type\n    code = INCOMPATIBLE_TYPES\n    term1 = t[0]\n    type1 = type of t[0]\n    term2 = t[i]\n    type2 = type of t[i]\n"]
    pub fn yices_bvand(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvor(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvxor(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvand2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvor2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvxor2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvand3(t1: term_t, t2: term_t, t3: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvor3(t1: term_t, t2: term_t, t3: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvxor3(t1: term_t, t2: term_t, t3: term_t) -> term_t;
}
extern "C" {
    #[doc = " Sum of n bitvector terms t[0] ... t[n-1]\n - n must be positive\n - all t[i]s must be bitvector terms of the same type (same number of bits)\n\n Return NULL_TERM if there's an error.\n\n Error reports:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if t[i] is not valid\n    code = INVALID_TERM\n    term1 = t[i]\n if t[i] is not a bitvector term\n    code = BITVECTOR_REQUIRED\n    badval = n\n if t[0] and t[i] don't have the same bitvector type\n    code = INCOMPATIBLE_TYPES\n    term1 = t[0]\n    type1 = type of t[0]\n    term2 = t[i]\n    type2 = type of t[i]"]
    pub fn yices_bvsum(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Product of n bitvector terms t[0] ... t[n-1]\n\n - n must be positive\n - all t[i]s must be bitvector terms of the same type (same number of bits)\n\n Return NULL_TERM if there's an error.\n\n Error reports:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if t[i] is not valid\n    code = INVALID_TERM\n    term1 = t[i]\n if t[i] is not a bitvector term\n    code = BITVECTOR_REQUIRED\n    term1 = t[i]\n if t[0] and t[i] don't have the same bitvector type\n    code = INCOMPATIBLE_TYPES\n    term1 = t[0]\n    type1 = type of t[0]\n    term2 = t[i]\n    type2 = type of t[i]\n if the result has degree > YICES_MAX_DEGREE\n    code = DEGREE_OVERFLOW\n    badval = degree"]
    pub fn yices_bvproduct(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Shift or rotation by an integer constant n\n - shift_left0 sets the low-order bits to zero\n - shift_left1 sets the low-order bits to one\n - shift_right0 sets the high-order bits to zero\n - shift_right1 sets the high-order bits to one\n - ashift_right is arithmetic shift, it copies the sign bit\n - rotate_left: circular rotation\n - rotate_right: circular rotation\n\n If t is a vector of m bits, then n must satisfy 0 <= n <= m.\n\n The functions return NULL_TERM (-1) if there's an error.\n\n Error reports:\n if t is not valid\n   code = INVALID_TERM\n   term1 = t\n if t is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t\n if n > size of t\n   code = INVALID_BITSHIFT\n   badval = n"]
    pub fn yices_shift_left0(t: term_t, n: u32) -> term_t;
}
extern "C" {
    pub fn yices_shift_left1(t: term_t, n: u32) -> term_t;
}
extern "C" {
    pub fn yices_shift_right0(t: term_t, n: u32) -> term_t;
}
extern "C" {
    pub fn yices_shift_right1(t: term_t, n: u32) -> term_t;
}
extern "C" {
    pub fn yices_ashift_right(t: term_t, n: u32) -> term_t;
}
extern "C" {
    pub fn yices_rotate_left(t: term_t, n: u32) -> term_t;
}
extern "C" {
    pub fn yices_rotate_right(t: term_t, n: u32) -> term_t;
}
extern "C" {
    #[doc = " Extract a subvector of t\n - t must be a bitvector term of size m\n - i and j must satisfy i <= j <= m-1\n The result is the bits i to j of t.\n\n Return NULL_TERM (-1) if there's an error.\n\n Error reports:\n if t is not valid\n   code = INVALID_TERM\n   term1 = t\n if t is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t\n if i <= j <= m-1 does not hold\n   code = INVALID_BVEXTRACT"]
    pub fn yices_bvextract(t: term_t, i: u32, j: u32) -> term_t;
}
extern "C" {
    #[doc = " Concatenation\n - t1 and t2 must be bitvector terms\n\n NOTE: t1 is the high-order part of the result, t2 is the low-order part.\n For example, if t1 is 0b0000 and t2 is 0b11111, then the function will\n construct 0b000011111.\n\n Return NULL_TERM (-1) if there's an error.\n\n Error reports\n if t1 or t2 is not a valid term\n   code = INVALID_TERM\n   term1 = t1 or t2\n if t1 or t2 is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t1 or t2\n if the size of the result would be larger than MAX_BVSIZE\n   code = MAX_BVSIZE_EXCEEDED\n   badval = n1 + n2 (n1 = size of t1, n2 = size of t2)"]
    pub fn yices_bvconcat2(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " General form of concatenation: the input is an array of n bitvector terms\n - n must be positive.\n\n NOTE: t[0] is the high-order part of the result, and t[n-1] is the low-order\n part. For example, if n=3, t[0] is 0b000, t[1] is 0b111, and t[2] is 0b01, then\n the function constructs 0b00011101.\n\n Error reports:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if t[i] is not valid\n    code = INVALID_TERM\n    term1 = t[i]\n if t[i] is not a bitvector term\n    code = BITVECTOR_REQUIRED\n    term1 = t[i]\n if the size of the result would be more than YICES_MAX_BVSIZE\n    code = MAX_BVSIZE_EXCEEDED\n    badval = sum of the size of t[i]s"]
    pub fn yices_bvconcat(n: u32, t: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Repeated concatenation:\n - make n copies of t and concatenate them\n - n must be positive\n\n Return NULL_TERM (-1) if there's an error\n\n Error report:\n if t is not valid\n   code = INVALID_TERM\n   term1 = t\n if t is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t\n if n == 0\n   code = POS_INT_REQUIRED\n   badval = n\n if n * size of t > MAX_BVSIZE\n   code = MAX_BVSIZE_EXCEEDED\n   badval = n * size of t"]
    pub fn yices_bvrepeat(t: term_t, n: u32) -> term_t;
}
extern "C" {
    #[doc = " Sign extension\n - add n copies of t's sign bit\n\n Return NULL_TERM if there's an error.\n\n Error reports:\n if t is invalid\n   code = INVALID_TERM\n   term1 = t\n if t is not a bitvector\n   code = BITVECTOR_REQUIRED\n   term1 = t\n if n + size of t > MAX_BVSIZE\n   code = MAX_BVSIZE_EXCEEDED\n   badval = n * size of t"]
    pub fn yices_sign_extend(t: term_t, n: u32) -> term_t;
}
extern "C" {
    #[doc = " Zero extension\n - add n zeros to t\n\n Return NULL_TERM if there's an error.\n\n Error reports:\n if t is invalid\n   code = INVALID_TERM\n   term1 = t\n if t is not a bitvector\n   code = BITVECTOR_REQUIRED\n   term1 = t\n if n + size of t > MAX_BVSIZE\n   code = MAX_BVSIZE_EXCEEDED\n   badval = n * size of t"]
    pub fn yices_zero_extend(t: term_t, n: u32) -> term_t;
}
extern "C" {
    #[doc = " AND-reduction:\n if t is b[m-1] ... b[0], then the result is a bit-vector of 1 bit\n equal to the conjunction of all bits of t (i.e., (and b[0] ... b[m-1])\n\n OR-reduction: compute (or b[0] ... b[m-1])\n\n Return NULL_TERM if there's an error\n\n Error reports:\n if t is invalid\n   code = INVALID_TERM\n   term1 = t\n if t is not a bitvector\n   code = BITVECTOR_REQUIRED\n   term1 = t"]
    pub fn yices_redand(t: term_t) -> term_t;
}
extern "C" {
    pub fn yices_redor(t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Bitwise equality comparison: if t1 and t2 are bitvectors of size n,\n construct (bvredand (bvxnor t1 t2))\n\n Return NULL_TERM if there's an error\n\n Error reports:\n if t1 or t2 is not valid\n   code = INVALID_TERM\n   term1 = t1 or t2\n if t1 or t2 is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t1 or t2\n if t1 and t2 do not have the same bitvector type\n   code = INCOMPATIBLE_TYPES\n   term1 = t1\n   type1 = type of t1\n   term2 = t2\n   type2 = type of t2"]
    pub fn yices_redcomp(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Convert an array of boolean terms arg[0 ... n-1] into\n a bitvector term of n bits\n - arg[0] = low-order bit of the result\n - arg[n-1] = high-order bit\n\n Error report:\n if n == 0\n    code = POS_INT_REQUIRED\n    badval = n\n if n > YICES_MAX_BVSIZE\n    code = MAX_BVSIZE_EXCEEDED\n    badval = size\n if arg[i] is invalid\n    code = INVALID_TERM\n    term1 = arg[i]\n if arg[i] is not a boolean\n    code = TYPE_MISMATCH\n    term1 = arg[i]\n    type1 = bool"]
    pub fn yices_bvarray(n: u32, arg: *const term_t) -> term_t;
}
extern "C" {
    #[doc = " Extract bit i of vector t (as a boolean)\n - if t is a bitvector of n bits, then i must be between 0 and n-1\n - the low-order bit of t has index 0\n - the high-order bit of t has index (n-1)\n\n Error report:\n if t is invalid\n    code = INVALID_TERM\n    term1 = t\n if t is not a bitvector term\n    code = BITVECTOR_REQUIRED\n    term1 = t\n if i >= t's bitsize\n    code = INVALID_BITEXTRACT"]
    pub fn yices_bitextract(t: term_t, i: u32) -> term_t;
}
extern "C" {
    #[doc = " Equality and disequality"]
    pub fn yices_bveq_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvneq_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Unsigned inequalities"]
    pub fn yices_bvge_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvgt_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvle_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvlt_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Signed inequalities"]
    pub fn yices_bvsge_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsgt_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvsle_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    pub fn yices_bvslt_atom(t1: term_t, t2: term_t) -> term_t;
}
extern "C" {
    #[doc = " Parsing uses the Yices language (cf. doc/YICES-LANGUAGE)\n - convert an input string s to a type or term.\n - s must be terminated by '\\0'\n\n The parsing function return NULL_TYPE or NULL_TERM if there's an\n error and set the error report. The line and column fields of the\n error report give information about the error location."]
    pub fn yices_parse_type(s: *const ::std::os::raw::c_char) -> type_t;
}
extern "C" {
    pub fn yices_parse_term(s: *const ::std::os::raw::c_char) -> term_t;
}
extern "C" {
    #[doc = " Apply the substitution defined by arrays var and map to a term t\n - var must be an array of n terms. Each element of var must\n   be either an uninterpreted term or a variable.\n   (cf. yices_new_uninterpreted_term and yices_new_variable).\n - map must be an array of n terms\n - the type of map[i] must be a subtype of var[i]'s type\n - every occurrence of var[i] in t is replaced by map[i]\n - if an uninterpreted term / variable occurs several times in v,\n   the last occurrence counts.\n   (e.g., if v[i] = x and v[j] = x with i < j, and\n   there are no other occurrences of x in v, then x is\n   replaced by map[j]).\n\n Return the resulting term or NULL_TERM if there's an error.\n\n Error codes:\n - INVALID_TERM if var[i] or map[i] is not valid\n - VARIABLE_REQUIRED if var[i] is not a variable or an uninterpreted term\n - TYPE_MISMATCH if map[i]'s type is not a subtype of var[i]'s type\n - DEGREE_OVERFLOW if the substitution causes an overflow"]
    pub fn yices_subst_term(n: u32, var: *const term_t, map: *const term_t, t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Apply a substitution to m terms in parallel\n - the substitution is defined by arrays var and map:\n   var must be an array of n variables or uninterpreted terms\n   map must be an array of n terms\n   map[i]'s type must be a subtype of var[i]'s type\n - the substitution is applied to terms t[0] ... t[m-1]\n - on entry to the function: t[i] must be a valid term\n   the function applies the substitution to t[i]\n   then store the result in place (i.e., t[i] := subst(n, var, map, t[i])).\n\n Note: it's more efficient to call this function than to call\n yices_subst_term m times.\n\n Return code:\n  0 if all goes well\n -1 if there's an error\n\n Error codes: as above"]
    pub fn yices_subst_term_array(
        n: u32,
        var: *const term_t,
        map: *const term_t,
        m: u32,
        t: *mut term_t,
    ) -> i32;
}
extern "C" {
    #[doc = " The following functions attach a name to a type or a term\n - name  must be a '\\0'-terminated string\n - if tau or t does not have a base name yet, then name is stored\n   as base name for tau or t.\n - if name referred to another term or another type, then this\n   previous mapping is hidden\n\n The functions return -1 and set the error report if the term or\n type is invalid. Otherwise they return 0.\n\n A copy of string name is made internally."]
    pub fn yices_set_type_name(tau: type_t, name: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    pub fn yices_set_term_name(t: term_t, name: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Remove the current mapping of name\n - no effect if name is not assigned to a term or type\n - if name is assigned to some term t or type tau, then this current\n   mapping is removed. If name was previously mapped to another term\n   or type, then the previous mapping is restored."]
    pub fn yices_remove_type_name(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn yices_remove_term_name(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get type or term of the given name\n - return NULL_TYPE or NULL_TERM if there's no type or term with that name"]
    pub fn yices_get_type_by_name(name: *const ::std::os::raw::c_char) -> type_t;
}
extern "C" {
    pub fn yices_get_term_by_name(name: *const ::std::os::raw::c_char) -> term_t;
}
extern "C" {
    #[doc = " Remove the base name of a type tau or of a term t.\n\n The functions return -1 and set the error report if the\n type or term is invalid. Otherwise, they return 0.\n\n If tau or t doesn't have a base name, the functions do\n nothing and return 0.\n\n Otherwise, the mapping from the base_name to tau or t is removed\n from the symbol table for terms or types, and the base_name of\n tau or t is set to NULL (i.e., tau or t don't have a base name anymore)."]
    pub fn yices_clear_type_name(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_clear_term_name(t: term_t) -> i32;
}
extern "C" {
    #[doc = " Get the base name of a term or type\n\n The functions return NULL if the  term or type has no name,\n or if the term or type is not valid. The error report is set\n to INVALID_TERM or INVALID_TYPE in such cases."]
    pub fn yices_get_type_name(tau: type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn yices_get_term_name(t: term_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the type of term t\n returns NULL_TYPE if t is not a valid term\n and sets the error report:\n   code = INVALID_TERM\n   term1 = t"]
    pub fn yices_type_of_term(t: term_t) -> type_t;
}
extern "C" {
    #[doc = " Check the type of a term t:\n - returns 0 for false, 1 for true\n\n - term_is_arithmetic checks whether t's type is either int or real\n - term_is_real checks whether t's type is real\n - term_is_int checks whether t's type is int\n - term_is_scalar checks whether t has a scalar or uninterpreted type\n\n If t is not a valid term, the check functions return false\n and set the error report as above."]
    pub fn yices_term_is_bool(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_int(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_real(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_arithmetic(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_bitvector(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_tuple(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_function(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_scalar(t: term_t) -> i32;
}
extern "C" {
    #[doc = " Size of a bitvector term (i.e., number of bits)\n - returns 0 if there's an error\n\n Error report:\n if t is not a valid term\n    code = INVALID_TERM\n    term1 = t\n if t is not a bitvector term\n    code = BITVECTOR_REQUIRED\n    term1 = t"]
    pub fn yices_term_bitsize(t: term_t) -> u32;
}
extern "C" {
    #[doc = " Check whether t is a ground term (i.e., does not have free variables)\n - return 0 for false, 1 for true\n\n Also return false and set the error report if t is not valid"]
    pub fn yices_term_is_ground(t: term_t) -> i32;
}
extern "C" {
    #[doc = " The following functions check the structure of a term_t.\n They return 0 for false, 1 for true.\n\n If t is not a valid term, then the functions return 0\n and set the error report:\n    code = INVALID_TERM\n    term1 = t"]
    pub fn yices_term_is_atomic(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_composite(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_projection(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_sum(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_bvsum(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_term_is_product(t: term_t) -> i32;
}
extern "C" {
    #[doc = " Constructor of term t:\n - if t is a valid term, the function returns one of the following codes\n   defined in yices_types.h:\n\n   if t is atomic:\n\n    YICES_BOOL_CONSTANT        boolean constant\n    YICES_ARITH_CONSTANT       rational constant\n    YICES_BV_CONSTANT          bitvector constant\n    YICES_SCALAR_CONSTANT      constant of uninterpreted/scalar\n    YICES_VARIABLE             variable in quantifiers/lambda terms\n    YICES_UNINTERPRETED_TERM   global variables\n\n   if t is a composite terms:\n\n    YICES_ITE_TERM             if-then-else\n    YICES_APP_TERM             application of an uninterpreted function\n    YICES_UPDATE_TERM          function update\n    YICES_TUPLE_TERM           tuple constructor\n    YICES_EQ_TERM              equality\n    YICES_DISTINCT_TERM        (distinct t_1 ... t_n)\n    YICES_FORALL_TERM          quantifier\n    YICES_LAMBDA_TERM          lambda\n    YICES_NOT_TERM             (not t)\n    YICES_OR_TERM              n-ary OR\n    YICES_XOR_TERM             n-ary XOR\n\n    YICES_BV_ARRAY             array of boolean terms\n    YICES_BV_DIV               unsigned division\n    YICES_BV_REM               unsigned remainder\n    YICES_BV_SDIV              signed division\n    YICES_BV_SREM              remainder in signed division (rounding to 0)\n    YICES_BV_SMOD              remainder in signed division (rounding to -infinity)\n    YICES_BV_SHL               shift left (padding with 0)\n    YICES_BV_LSHR              logical shift right (padding with 0)\n    YICES_BV_ASHR              arithmetic shift right (padding with sign bit)\n    YICES_BV_GE_ATOM           unsigned bitvector comparison: (t1 >= t2)\n    YICES_BV_SGE_ATOM          signed bitvector comparison (t1 >= t2)\n\n    YICES_ARITH_GE_ATOM        arithmetic comparison (t1 >= t2)\n    YICES_ARITH_ROOT_ATOM      nonlinear arithmetic constraint\n\n   if t is a projection\n\n    YICES_SELECT_TERM          tuple projection\n    YICES_BIT_TERM             bit-select: extract the i-th bit of a bitvector\n\n   if t is a sum\n\n    YICES_BV_SUM               sum of pairs a * t where a is a bitvector constant (and t is a bitvector term)\n    YICES_ARITH_SUM            sum of pairs a * t where a is a rational (and t is an arithmetic term)\n\n  if t is a product\n\n    YICES_POWER_PRODUCT         power products: (t1^d1 * ... * t_n^d_n)\n\n If t is not a valid term, the function returns a negative number,\n (i.e., YICES_CONSTRUCTOR_ERROR) and sets the error report.\n    code = INVALID_TERM\n    term1 = t"]
    pub fn yices_term_constructor(t: term_t) -> term_constructor_t;
}
extern "C" {
    #[doc = " Number of children of term t\n - for atomic terms, returns 0\n - for composite terms, returns the number of children\n - for projections, returns 1\n - for sums, returns the number of summands\n - for products, returns the number of factors\n\n - returns -1 if t is not a valid term and sets the error report"]
    pub fn yices_term_num_children(t: term_t) -> i32;
}
extern "C" {
    #[doc = " Get i-th child of a composite term\n - if t has n children (as returned by yices_term_num_children)\n   then i must be between 0 and n-1.\n\n - the function returns NULL_TERM if there's an error.\n\n Error codes:\n if t is not valid\n    code = INVALID_TERM\n    term1 = t\n if t is not a composite, or i is not in the range [0 .. n-1]\n    code = INVALID_TERM_OP"]
    pub fn yices_term_child(t: term_t, i: i32) -> term_t;
}
extern "C" {
    #[doc = " Collect all the children of composite term t in vector *v\n - v must be initialized by calling yices_init_term_vector\n - if t s not valid or is not a composite term, the function\n   returns -1 and leaves *v unchanged\n - otherwise, the children are stored in *v:\n    v->size = number of children\n    v->data[0 ... v->size-1] = the children\n\n The vector->size is equal to yices_term_num_children(t).\n The children are stored in the same order as given by yices_term_child:\n    v->data[i] = child of index i.\n\n Error report:\n if t is not a valid type\n   code = INVALID_TERM\n   term1 = t\n if t is not a composite term\n   code = INVALID_TERM_OP\n\n Since 2.6.2."]
    pub fn yices_term_children(t: term_t, v: *mut term_vector_t) -> i32;
}
extern "C" {
    #[doc = " Get the argument and index of a projection\n - if t is invalid or not a projection term then\n     yices_proj_index returns -1\n     yices_proj_arg returns NULL_TERM\n\n Error codes:\n if t is not valid\n    code = INVALID_TERM\n    term1 = t\n if t is not a projection\n    code = INVALID_TERM_OP"]
    pub fn yices_proj_index(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_proj_arg(t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Value of a constant term:\n - these functions return 0 if t is a valid term and store t's value\n   in *val (or in q)\n - if t is invalid or it's not the right kind of term, then the\n   functions return -1 and leave *val unchanged.\n\n For yices_rational_const_value, q must be initialized.\n\n Error codes:\n if t is not valid\n    code = INVALID_TERM\n    term1 = t\n if t is not of the right kind\n    code = INVALID_TERM_OP"]
    pub fn yices_bool_const_value(t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    pub fn yices_bv_const_value(t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    pub fn yices_scalar_const_value(t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    pub fn yices_bvsum_component(t: term_t, i: i32, val: *mut i32, term: *mut term_t) -> i32;
}
extern "C" {
    #[doc = " Component of power product t\n - i = index (must be between 0 and t's arity - 1)\n - the component is of the form (term, exponent)\n   (where exponent is a positive integer)\n\n The function returns 0 on success and -1 on error.\n\n Error codes:\n if t is not valid\n    code = INVALID_TERM\n    term1 = t\n if t is not of the right kind or i is invalid\n    code = INVALID_TERM_OP"]
    pub fn yices_product_component(t: term_t, i: i32, term: *mut term_t, exp: *mut u32) -> i32;
}
extern "C" {
    #[doc = " The following functions can be used to get the number of terms\n and types currently stored in the internal data structures."]
    pub fn yices_num_terms() -> u32;
}
extern "C" {
    pub fn yices_num_types() -> u32;
}
extern "C" {
    #[doc = " Reference counting support:\n - the functions return -1 if there's an error, 0 otherwise\n\n Error reports:\n - INVALID_TERM or INVALID_TYPE if the argument is not valid\n\n The decref functions also report an error if the argument has a\n current reference count of zero. The error report's code is set to\n BAD_TERM_DECREF or BAD_TYPE_DECREF in such a case."]
    pub fn yices_incref_term(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_decref_term(t: term_t) -> i32;
}
extern "C" {
    pub fn yices_incref_type(tau: type_t) -> i32;
}
extern "C" {
    pub fn yices_decref_type(tau: type_t) -> i32;
}
extern "C" {
    #[doc = " The following functions give the number of terms and types\n that have a positive reference count. They return 0 if\n no call to yices_incref_term or yices_incref_type has been\n made."]
    pub fn yices_num_posref_terms() -> u32;
}
extern "C" {
    pub fn yices_num_posref_types() -> u32;
}
extern "C" {
    #[doc = " Call the garbage collector.\n - t = optional array of terms\n - nt = size of t\n - tau = optional array of types\n - ntau = size of tau\n - keep_named specifies whether the named terms and types should\n   all be preserved\n\n The set of roots is determined as follows:\n 1) all terms/types used by contexts and models are roots.\n 2) if t is non NULL, then all elements in t[0 ... nt-1] are added to\n    the set of root terms.\n 3) if tau is non NULL, then all elements in tau[0 ... ntau - 1] are added\n    to the set of root types.\n 4) if keep_named is non zero (i.e., true), then all terms and types\n    that are referenced in the symbol tables are added to the set of\n    roots.\n 5) all terms and types with a positive reference count are added to\n    the set of roots.\n\n The function silently ignores any term t[i] or any type tau[j] that's not valid."]
    pub fn yices_garbage_collect(
        t: *const term_t,
        nt: u32,
        tau: *const type_t,
        ntau: u32,
        keep_named: i32,
    );
}
extern "C" {
    #[doc = " Allocate a configuration descriptor:\n - the descriptor is set to the default configuration"]
    pub fn yices_new_config() -> *mut ctx_config_t;
}
extern "C" {
    #[doc = " Deletion"]
    pub fn yices_free_config(config: *mut ctx_config_t);
}
extern "C" {
    #[doc = " Set a configuration parameter:\n - name = the parameter name\n - value = the value\n\n The following table specifies the parameters and allowed values for each parameter name:\n\n            name    |    value            |      meaning\n   ----------------------------------------------------------------------------------------\n            \"mode\"  | \"one-shot\"          |  only one call to check is supported\n                    |                     |\n                    | \"multi-checks\"      |  several calls to assert and check are\n                    |                     |  possible\n                    |                     |\n                    | \"push-pop\"          |  like multi-check and with support for\n                    |                     |  retracting assertions (via push/pop)\n                    |                     |\n                    | \"interactive\"       |  like push-pop, but with automatic context clean\n                    |                     |  up when search is interrupted.\n   ----------------------------------------------------------------------------------------\n    \"solver-type\"   | \"dpllt\"             | DPLL(T) style solver (default)\n                    | \"mcsat\"             | MCSat style solver\n   ----------------------------------------------------------------------------------------\n    \"uf-solver\"     | \"default\"           |  the uf-solver is included (i.e., the egraph)\n                    | \"none\"              |  no uf-solver\n   ----------------------------------------------------------------------------------------\n    \"bv-solver\"     | \"default\"           |  the bitvector solver is included\n                    | \"none\"              |  no bitvector solver\n   ----------------------------------------------------------------------------------------\n    \"array-solver\"  | \"default\"           |  the array solver is included\n                    | \"none\"              |  no array solver\n   ----------------------------------------------------------------------------------------\n    \"arith-solver\"  | \"ifw\"               |  solver for IDL, based on the Floyd-Warshall\n                    |                     |  algorithm\n                    |                     |\n                    | \"rfw\"               |  solver for RDL, based on Floyd-Warshall\n                    |                     |\n                    | \"simplex\"           |  solver for linear arithmetic, based on Simplex\n                    |                     |\n                    | \"default\"           |  same as \"simplex\"\n                    |                     |\n                    | \"auto\"              |  same as \"simplex\" unless mode=\"one-shot\" and\n                    |                     |  logic is QF_IDL or QF_RDL, in which case the\n                    |                     |  solver is determined after the first call to\n                    |                     |  yices_assert_formula(s).\n                    |                     |\n                    | \"none\"              |  no arithmetic solver\n   ----------------------------------------------------------------------------------------\n   \"arith-fragment\" | \"IDL\"               |  integer difference logic\n                    | \"RDL\"               |  real difference logic\n                    | \"LIA\"               |  linear integer arithmetic\n                    | \"LRA\"               |  linear real arithmetic\n                    | \"LIRA\"              |  mixed linear arithmetic (real + integer variables)\n   ----------------------------------------------------------------------------------------\n   \"model-interpolation\" | \"false\"        | don't enable model interpolation (default)\n                         | \"true\"         | enable model interpolation\n\n\n The function returns -1 if there's an error, 0 otherwise.\n\n Error codes:\n  CTX_UNKNOWN_PARAMETER if name is not a known parameter name\n  CTX_INVALID_PARAMETER_VALUE if name is known but value does not match the parameter type"]
    pub fn yices_set_config(
        config: *mut ctx_config_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Set config to a default solver type or solver combination for the given logic\n - return -1 if there's an error\n - return 0 otherwise\n\n The logic must be given as a string, using the SMT-LIB conventions.\n Currently, Yices recognizes and supports the following logics:\n\n   NONE:        no theories (i.e., propositional logic only)\n\n   QF_AX:       arrays with extensionality\n   QF_BV:       bitvectors\n   QF_IDL:      integer difference logic\n   QF_RDL:      real difference logic\n   QF_LIA:      linear integer arithmetic\n   QF_LRA:      linear real arithmetic\n   QF_LIRA:     mixed linear arithmetic\n   QF_UF:       uninterpreted functions\n\n   QF_ABV:      arrays and bitvectors\n   QF_ALIA:     arrays + linear integer arithmetic\n   QF_ALRA:     arrays + linear real arithmetic\n   QF_ALIRA:    arrays + mixed linear arithmetic\n\n   QF_AUF:      arrays + uninterpreted functions\n   QF_AUFBV:    arrays, bitvectors, uninterpreted functions\n   QF_AUFLIA:   arrays, uninterpreted functions, and linear integer arithmetic\n   QF_AUFLRA:   arrays, uninterpreted functions, and linear real arithmetic\n   QF_AUFLIRA:  arrays, uninterpreted functions, and mixed linear arithmetic\n\n   QF_UFBV:     uninterpreted functions + bitvectors\n   QF_UFIDL:    uninterpreted functions + integer difference logic\n   QF_UFLIA:    uninterpreted functions + linear integer arithmetic\n   QF_UFLRA:    uninterpreted functions + linear real arithmetic\n   QF_UFLIRA:   uninterpreted functions + mixed linear arithmetic\n   QF_UFRDL:    uninterpreted functions + real difference logic\n\n   QF_NIA:      non-linear integer arithmetic\n   QF_NRA:      non-linear real arithmetic\n   QF_NIRA:     non-linear mixed arithmetic\n\n   QF_UFNIA:    uninterpreted functions + non-linear integer arithmetic\n   QF_UFNRA:    uninterpreted functions + non-linear real arithmetic\n   QF_UFNIRA:   uninterpreted functions + mixed, non-linear arithmetic\n\n In all these logics, QF means quantifier-free.\n\n For future extensions, Yices also recognizes the following names\n for logics that Yices does not support yet. (They combine arrays and\n non-linear arithmetic).\n\n   QF_ANIA:     arrays + non-linear integer arithmetic\n   QF_ANRA:     arrays + non-linear real arithmetic\n   QF_ANIRA:    arrays + mixed/non-linear arithmetic\n\n   QF_AUFNIA:   arrays + uninterpreted functions + non-linear integer arithmetic\n   QF_AUFNRA:   arrays + uninterpreted functions + non-linear real arithmetic\n   QF_AUFNIRA:  arrays + uninterpreted functions + mixed, non-linear arithmetic\n\n For every QF logic listed above, Yices also recognizes the full logic (i.e.,\n with quantifiers). This is for future extension. Yices does not include support\n for quantifiers yet. For example, Yices recognizes AUFLIRA as a valid logic name\n (arrays + uninterpreted functions + mixed linear arithmetic), but this logic is\n not currently supported.\n\n Since release 2.6.0, you can also use the name \"ALL\" as a logic\n name.  This has the same interpretation as using \"(set-logic ALL)\n in yices-smt2. For the current release, this logic name specifies\n quantifier-free combination of arrays + uninterpreted functions +\n mixed linear arithmetic + bitvectors.\n\n\n Error codes:\n\n  CTX_UNKNOWN_LOGIC if logic is not a valid name\n  CTX_LOGIC_NOT_SUPPORTED if logic is known but not supported"]
    pub fn yices_default_config_for_logic(
        config: *mut ctx_config_t,
        logic: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Create a new context:\n - config is an optional argument that defines the context configuration\n - the configuration specifies which components the context should\n   include (e.g., egraph, bv_solver, simplex_solver, etc),\n   and which features should be supported (e.g., whether push/pop are\n   needed).\n\n If config is NULL, the default configuration is used:\n   push/pop are enabled\n   the solvers are: egraph + array solver + bv solver + simplex\n   mixed real/integer linear arithmetic is supported\n\n Otherwise the context is configured as specified by config, provided\n that configuration is valid.\n\n If there's an error (i.e., the configuration is not supported), the\n function returns NULL and set an error code: CTX_INVALID_CONFIG."]
    pub fn yices_new_context(config: *const ctx_config_t) -> *mut context_t;
}
extern "C" {
    #[doc = " Deletion"]
    pub fn yices_free_context(ctx: *mut context_t);
}
extern "C" {
    #[doc = " Get status: return the context's status flag\n - return one of the codes defined in yices_types.h,\n   namely one of the constants\n\n    STATUS_IDLE\n    STATUS_SEARCHING\n    STATUS_UNKNOWN\n    STATUS_SAT\n    STATUS_UNSAT\n    STATUS_INTERRUPTED\n"]
    pub fn yices_context_status(ctx: *mut context_t) -> smt_status_t;
}
extern "C" {
    #[doc = " Reset: remove all assertions and restore ctx's\n status to STATUS_IDLE."]
    pub fn yices_reset_context(ctx: *mut context_t);
}
extern "C" {
    #[doc = " Push: mark a backtrack point\n - return 0 if this operation is supported by the context\n         -1 otherwise\n\n Error report:\n - if the context is not configured to support push/pop\n   code = CTX_OPERATION_NOT_SUPPORTED\n - if the context status is STATUS_UNSAT or STATUS_SEARCHING or STATUS_INTERRUPTED\n   code = CTX_INVALID_OPERATION"]
    pub fn yices_push(ctx: *mut context_t) -> i32;
}
extern "C" {
    #[doc = " Pop: backtrack to the previous backtrack point (i.e., the matching\n call to yices_push).\n - return 0 if the operation succeeds, -1 otherwise.\n\n Error report:\n - if the context is not configured to support push/pop\n   code = CTX_OPERATION_NOT_SUPPORTED\n - if there's no matching push (i.e., the context stack is empty)\n   or if the context's status is STATUS_SEARCHING\n   code = CTX_INVALID_OPERATION"]
    pub fn yices_pop(ctx: *mut context_t) -> i32;
}
extern "C" {
    #[doc = " Several options determine how much simplification is performed\n when formulas are asserted. It's best to leave them untouched\n unless you really know what you're doing.\n\n The following functions selectively enable/disable a preprocessing\n option. In the description below we use \"variable\" for what should be\n \"uninterpreted term\" (in the sense of Yices), to stick to standard\n terminology. The current options include:\n\n   var-elim: whether to eliminate variables by substitution\n\n   arith-elim: more variable elimination for arithmetic (Gaussian elimination)\n\n   bvarith-elim: more variable elimination for bitvector arithmetic\n\n   eager-arith-lemmas: if enabled and the simplex solver is used, the simplex\n   solver will eagerly generate lemmas such as (x >= 1) => (x >= 0) (i.e.,\n   the lemmas that involve two inequalities on the same variable x).\n\n   flatten: whether to flatten nested (or ...)\n   if this is enabled the term (or (or a b) (or c d) ) is\n   flattened to (or a b c d)\n\n   learn-eq: enable/disable heuristics to learn implied equalities\n\n   keep-ite: whether to eliminate term if-then-else or keep them as terms\n   - this requires the context to include the egraph\n\n   break-symmetries: attempt to detect symmetries and add constraints\n   to remove them (this can be used only if the context is created for QF_UF)\n\n   assert-ite-bounds: try to determine upper and lower bound on if-then-else\n   terms and assert these bounds. For example, if term t is defined as\n   (ite c 10 (ite d 3 20)), then the context with include the assertion\n   3 <= t <= 20.\n\n The parameter must be given as a string. For example, to disable var-elim,\n call  yices_context_disable_option(ctx, \"var-elim\")\n\n The two functions return -1 if there's an error, 0 otherwise.\n\n Error codes:\n  CTX_UNKNOWN_PARAMETER if the option name is not one of the above."]
    pub fn yices_context_enable_option(
        ctx: *mut context_t,
        option: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn yices_context_disable_option(
        ctx: *mut context_t,
        option: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Assert formula t in ctx\n - ctx status must be STATUS_IDLE or STATUS_UNSAT or STATUS_SAT or STATUS_UNKNOWN\n - t must be a boolean term\n\n If ctx's status is STATUS_UNSAT, nothing is done.\n\n If ctx's status is STATUS_IDLE, STATUS_SAT, or STATUS_UNKNOWN, then\n the formula is simplified and  asserted in the context. The context\n status is changed  to STATUS_UNSAT if the formula  is simplified to\n 'false' or to STATUS_IDLE otherwise.\n\n This returns 0 if there's no error or -1 if there's an error.\n\n Error report:\n if t is invalid\n   code = INVALID_TERM\n   term1 = t\n if t is not boolean\n   code = TYPE_MISMATCH\n   term1 = t\n   type1 = bool (expected type)\n if ctx's status is not STATUS_IDLE or STATUS_UNSAT or STATUS_SAT or STATUS_UNKNOWN\n   code = CTX_INVALID_OPERATION\n if ctx's status is neither STATUS_IDLE nor STATUS_UNSAT, and the context is\n not configured for multiple checks\n   code = CTX_OPERATION_NOT_SUPPORTED\n\n Other error codes are defined in yices_types.h to report that t is\n outside the logic supported by ctx."]
    pub fn yices_assert_formula(ctx: *mut context_t, t: term_t) -> i32;
}
extern "C" {
    #[doc = " Assert an array of n formulas t[0 ... n-1]\n - ctx's status must be STATUS_IDLE or STATUS_UNSAT or STATUS_SAT or STATUS_UNKNOWN\n - all t[i]'s must be valid boolean terms.\n\n The function returns -1 on error, 0 otherwise.\n\n The error report is set as in the previous function."]
    pub fn yices_assert_formulas(ctx: *mut context_t, n: u32, t: *const term_t) -> i32;
}
extern "C" {
    #[doc = " Check satisfiability\n\n Check whether the assertions stored in ctx are satisfiable.\n - params is an optional structure that stores heuristic parameters.\n - if params is NULL, default parameter settings are used.\n\n It's better to keep params=NULL unless you encounter performance\n problems.  Then you may want to play with the heuristics to see if\n performance improves.\n\n The behavior and returned value depend on ctx's current status.\n\n 1) If ctx's status is STATUS_SAT, STATUS_UNSAT, or STATUS_UNKNOWN, the function\n    does nothing and just returns the status.\n\n 2) If ctx's status is STATUS_IDLE, then the solver searches for a\n    satisfying assignment. If param != NULL, the search parameters\n    defined by params are used.\n\n    The function returns one of the following codes:\n    - STATUS_SAT: the context is satisfiable\n    - STATUS_UNSAT: the context is not satisfiable\n    - STATUS_UNKNOWN: satisfiability can't be proved or disproved\n    - STATUS_INTERRUPTED: the search was interrupted\n\n    The returned status is also stored as the new ctx's status flag,\n    with the following exception. If the context was built with\n    mode = INTERACTIVE and the search was interrupted, then the\n    function returns STATUS_INTERRUPTED but the ctx's state is restored to\n    what it was before the call to 'yices_check_context' and the\n    status flag is reset to STATUS_IDLE.\n\n 3) Otherwise, the function does nothing and returns 'STATUS_ERROR',\n    it also sets the yices error report (code = CTX_INVALID_OPERATION)."]
    pub fn yices_check_context(ctx: *mut context_t, params: *const param_t) -> smt_status_t;
}
extern "C" {
    #[doc = " Check satisfiability under assumptions.\n\n Check whether the assertions stored in ctx conjoined with n assumptions are\n satisfiable.\n - params is an optional structure to store heuristic parameters\n - if params is NULL, default parameter settings are used.\n - n = number of assumptions\n - t = array of n assumptions\n - the assumptions t[0] ... t[n-1] must all be valid Boolean terms\n\n This function behaves the same as the previous function.\n If it returns STATUS_UNSAT, then one can construct an unsat core by\n calling function yices_get_unsat_core. The unsat core is a subset of t[0] ... t[n-1]\n that's inconsistent with ctx."]
    pub fn yices_check_context_with_assumptions(
        ctx: *mut context_t,
        params: *const param_t,
        n: u32,
        t: *const term_t,
    ) -> smt_status_t;
}
extern "C" {
    #[doc = " Check satisfiability modulo a model.\n\n Check whether the assertions stored in ctx conjoined with a model are satisfiable.\n - ctx must be a context initialized with support for MCSAT\n   (see yices_new_context, yices_new_config, yices_set_config).\n - params is an optional structure to store heuristic parameters\n   if params is NULL, default parameter settings are used.\n - mdl is a model\n - t is an array of n terms\n - the terms t[0] ... t[n-1] must all be uninterpreted terms\n\n This function checks statisfiability of the constraints in ctx conjoined with\n a conjunction of equalities defined by t[i] and the model, namely,\n\n    t[0] == v_0 /\\ .... /\\ t[n-1] = v_{n-1}\n\n where v_i is the value of t[i] in mdl.\n\n NOTE: if t[i] does not have a value in mdl, then a default value is picked for v_i.\n\n If this function returns STATUS_UNSAT and the context supports\n model interpolation, then one can construct a model interpolant by\n calling function yices_get_model_interpolant.\n\n Error codes:\n\n if one of the terms t[i] is not an uninterpreted term\n   code = MCSAT_ERROR_ASSUMPTION_TERM_NOT_SUPPORTED\n\n If the context does not have the MCSAT solver enabled\n   code = CTX_OPERATION_NOT_SUPPORTED\n\n If the resulting status is STATUS_SAT and context does not support multichecks\n   code = CTX_OPERATION_NOT_SUPPORTED\n\n\n Since 2.6.4."]
    pub fn yices_check_context_with_model(
        ctx: *mut context_t,
        params: *const param_t,
        mdl: *mut model_t,
        n: u32,
        t: *const term_t,
    ) -> smt_status_t;
}
extern "C" {
    #[doc = " Check satisfiability and compute interpolant.\n\n Check whether the combined assertions stored in ctx are satisfiable. If they are\n not, compute an interpolant (whose uninterpreted terms are common to both contexts).\n - params is an optional structure to store heuristic parameters\n - if params is NULL, default parameter settings are used.\n\n The interpolation_context is a structure with four components defined as follows:\n\n  typedef  struct interpolation_context_s {\n     context_t *ctx_A;\n     context_t *ctx_B;\n     term_t interpolant;\n     model_t *model;\n  } interpolation_context_t;\n\n To call this function:\n - ctx->ctx_A must be a context initialized with support for MCSAT and interpolation.\n - ctx->ctx_B can be another context (not necessarily with MCSAT support)\n\n If this function returns STATUS_UNSAT, then an interpolant is returned in ctx->interpolant.\n\n If this function returns STATUS_SAT and build_model is true, then\n a model is returned in ctx->model. This model must be freed when no-longer needed by\n calling yices_free_model.\n\n If something is wrong, the function returns STATUS_ERROR and sets the yices error report\n (code = CTX_INVALID_OPERATION).\n\n Since 2.6.4."]
    pub fn yices_check_context_with_interpolation(
        ctx: *mut interpolation_context_t,
        params: *const param_t,
        build_model: i32,
    ) -> smt_status_t;
}
extern "C" {
    #[doc = " Add a blocking clause: this is intended to help enumerate different models\n for a set of assertions.\n - if ctx's status is STATUS_SAT or STATUS_UNKNOWN, then a new clause is added to ctx\n   to remove the current truth assignment from the search space. After this\n   clause is added, the next call to yices_check_context will either produce\n   a different truth assignment (hence a different model) or return STATUS_UNSAT.\n\n - ctx's status flag is updated to STATUS_IDLE (if the new clause is not empty) or\n   to STATUS_UNSAT (if the new clause is the empty clause).\n\n Return code: 0 if there's no error, -1 if there's an error.\n\n Error report:\n if ctx's status is different from STATUS_SAT or STATUS_UNKNOWN\n    code = CTX_INVALID_OPERATION\n if ctx is not configured to support multiple checks\n    code = CTX_OPERATION_NOT_SUPPORTED"]
    pub fn yices_assert_blocking_clause(ctx: *mut context_t) -> i32;
}
extern "C" {
    #[doc = " Interrupt the search:\n - this can be called from a signal handler to stop the search,\n   after a call to yices_check_context to interrupt the solver.\n\n If ctx's status is STATUS_SEARCHING, then the current search is\n interrupted. Otherwise, the function does nothing."]
    pub fn yices_stop_search(ctx: *mut context_t);
}
extern "C" {
    #[doc = " Return a parameter record initialized with default settings."]
    pub fn yices_new_param_record() -> *mut param_t;
}
extern "C" {
    #[doc = " Set default search parameters for ctx."]
    pub fn yices_default_params_for_context(ctx: *const context_t, params: *mut param_t);
}
extern "C" {
    #[doc = " Set a parameter in record p\n - pname = parameter name\n - value = setting\n\n The parameters are explained in doc/YICES-LANGUAGE\n (and at http://yices.csl.sri.com/doc/parameters.html)\n\n Return -1 if there's an error, 0 otherwise.\n\n Error codes:\n - CTX_UNKNOWN_PARAMETER if pname is not a known parameter name\n - CTX_INVALID_PARAMETER_VALUE if value is not valid for the parameter"]
    pub fn yices_set_param(
        p: *mut param_t,
        pname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Delete the record param"]
    pub fn yices_free_param_record(param: *mut param_t);
}
extern "C" {
    #[doc = " Construct an unsat core and store the result in vector *v.\n - v must be an initialized term_vector\n\n If ctx status is unsat, this function stores an unsat core in v,\n and returns 0. Otherwise, it sets an error core an returns -1.\n\n This is intended to be used after a call to\n yices_check_context_with_assumptions that returned STATUS_UNSAT. In\n this case, the function builds an unsat core, which is a subset of\n the assumptions. If there were no assumptions or if the context is UNSAT\n for another reason, an empty core is returned (i.e., v->size is set to 0).\n\n Error code:\n - CTX_INVALID_OPERATION if the context's status is not STATUS_UNSAT."]
    pub fn yices_get_unsat_core(ctx: *mut context_t, v: *mut term_vector_t) -> i32;
}
extern "C" {
    #[doc = " Construct and return a model interpolant.\n\n If ctx status is unsat and the ctx was configured with model-interpolation,\n this function returns a model interpolant.\n Otherwise, it sets an error code and return NULL_TERM.\n\n This is intended to be used after a call to\n yices_check_context_with_model that returned STATUS_UNSAT. In this\n case, the function builds an model interpolant. The model\n interpolant is a clause implied by the current context that is\n false in the model provides to yices_check_context_with_model.\n\n Error code:\n - CTX_OPERATION_NOT_SUPPORTED if the context is not configured with model interpolation\n - CTX_INVALID_OPERATION if the context's status is not STATUS_UNSAT.\n\n Since 2.6.4."]
    pub fn yices_get_model_interpolant(ctx: *mut context_t) -> term_t;
}
extern "C" {
    #[doc = " Build a model from ctx\n - keep_subst indicates whether the model should include\n   the uninterpreted terms that have been eliminated by simplification:\n   keep_subst = 0 means don't keep substitutions,\n   keep_subst != 0 means keep them\n - ctx status must be STATUS_SAT or STATUS_UNKNOWN\n\n The function returns NULL if the status isn't SAT or STATUS_UNKNOWN\n and sets an error report (code = CTX_INVALID_OPERATION).\n\n When assertions are added to the context, the simplifications may\n eliminate some uninterpreted terms (cf. simplification options above).\n The flag 'keep_subst' indicates whether the model should keep track\n of these eliminated terms and include their value.\n\n Example: after the following assertions\n\n    (= x (bv-add y z))\n    (bv-gt y 0b000)\n    (bg-gt z 0b000)\n\n uninterpreted term 'x' gets eliminated. Then a call to 'check_context' will\n return STATUS_SAT and we can ask for a model 'M'\n - if 'keep_subst' is false then the value of 'x' in 'M' is unavailable.\n - if 'keep_subst' is true then the value of 'x' in 'M' is computed,\n   based on the value of 'y' and 'z' in 'M'.\n\n It's always better to set 'keep_subst' true. The only exceptions\n are some of the large SMT_LIB benchmarks where millions of uninterpreted\n terms are eliminated.  In such cases, it saves memory to set 'keep_subst'\n false, and model construction is faster too."]
    pub fn yices_get_model(ctx: *mut context_t, keep_subst: i32) -> *mut model_t;
}
extern "C" {
    #[doc = " Delete model mdl"]
    pub fn yices_free_model(mdl: *mut model_t);
}
extern "C" {
    #[doc = " Build an empty model: no error.\n\n Since 2.6.4."]
    pub fn yices_new_model() -> *mut model_t;
}
extern "C" {
    #[doc = " Build a model from a term-to-term mapping:\n - the mapping is defined by two arrays var[] and map[]\n - every element of var must be an uninterpreted term\n   every element of map must be a constant of primitive or tuple type\n   map[i]'s type must be a subtype of var[i]\n - there must not be duplicates in array var\n\n The function returns NULL and sets up the error report if something\n goes wrong. It allocates and creates a new model otherwise. When\n the model is no longer used, it must be deleted by calling yices_free_model.\n\n Error report:\n - code = INVALID_TERM if var[i] or map[i] is not valid\n - code = TYPE_MISMATCH if map[i]'s type is not a subtype of var[i]'s type\n - code = MDL_UNINT_REQUIRED if var[i] is not an uninterpreted term\n - code = MDL_CONSTANT_REQUIRED if map[i] is not a constant\n - code = MDL_DUPLICATE_VAR if var contains duplicate elements\n - code = MDL_FTYPE_NOT_ALLOWED if one of var[i] has a function type\n - code = MDL_CONSTRUCTION_FAILED: something else went wrong"]
    pub fn yices_model_from_map(n: u32, var: *const term_t, map: *const term_t) -> *mut model_t;
}
extern "C" {
    #[doc = " Assign a value to a Boolean uninterpreted term\n - val 0 means false, anything else means true.\n\n Since 2.6.4."]
    pub fn yices_model_set_bool(model: *mut model_t, var: term_t, val: i32) -> i32;
}
extern "C" {
    #[doc = " Assign a value to a numerical uninterpreted term.  The value can be given as\n an integer, a GMP integer, a GMP rational, or an algebraic number.\n\n The assignment fails (TYPE_MISMATCH) is the uninterpreted term has integer type\n and the value is not an integer.\n\n For functions yices_model_set_rational32 and\n yices_model_set_rational64, the value is num/den.  These two\n functions fail and report DIVISION_BY_ZERO if den is zero.\n\n Since 2.6.4."]
    pub fn yices_model_set_int32(model: *mut model_t, var: term_t, val: i32) -> i32;
}
extern "C" {
    pub fn yices_model_set_int64(model: *mut model_t, var: term_t, val: i64) -> i32;
}
extern "C" {
    pub fn yices_model_set_rational32(model: *mut model_t, var: term_t, num: i32, den: u32) -> i32;
}
extern "C" {
    pub fn yices_model_set_rational64(model: *mut model_t, var: term_t, num: i64, den: u64) -> i32;
}
extern "C" {
    #[doc = " Assign an integer value to a bitvector uninterpreted term.\n\n Rules for truncation and zero/sign extension:\n - let n be the number of bits in var\n - if val has more than n bits then it is truncated. The n least significant bits are used.\n   Other bits are ignored.\n - if val has fewer than n bits, the value is obtained by zero or sign extension, depending\n   on the function:\n     yices_model_set_bv_int32:  sign extension\n     yices_model_set_bv_int64:  sign extension\n     yices_model_set_bv_uint32: zero extension\n     yices_model_set_bv_uint64: zero extension\n     yices_model_set_bv_mpz:    sign extension\n\n\n Since 2.6.4."]
    pub fn yices_model_set_bv_int32(model: *mut model_t, var: term_t, val: i32) -> i32;
}
extern "C" {
    pub fn yices_model_set_bv_int64(model: *mut model_t, var: term_t, val: i64) -> i32;
}
extern "C" {
    pub fn yices_model_set_bv_uint32(model: *mut model_t, var: term_t, val: u32) -> i32;
}
extern "C" {
    pub fn yices_model_set_bv_uint64(model: *mut model_t, var: term_t, val: u64) -> i32;
}
extern "C" {
    #[doc = " Assign a bitvector value to a bitvector uninterpreted term, using an array of bits.\n - var = bitvector uninterpreted term\n - a = array of n bits\n - var must be an uninterpreted term of type (bitvector n)\n   (and var must not have a value in model).\n\n Elements of a are interpreted as in yices_bvconst_from_array:\n - bit i is 0 if a[i] == 0 and bit i is 1 if a[i] != 0\n - a[0] is the low-order bit\n - a[n-1] is the high-order bit\n\n\n Since 2.6.4."]
    pub fn yices_model_set_bv_from_array(
        model: *mut model_t,
        var: term_t,
        n: u32,
        a: *const i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Collect all the uninterpreted terms that have a value in model mdl.\n - these terms are returned in vector v\n - v must be an initialized term_vector\n\n If the model was produced from a context (i.e., returned by\n yices_get_model(context_t ctx, ...))  then vector v will contain\n all unintepreted terms that occurred in the asserted formulas.\n Warning: formula simplification may remove some uninterpreted terms.\n\n Trivial example:\n\n   (assert (and (> y 0) (= x x)))\n\n is simplified to\n\n   (assert (> y 0))\n\n then uninterpreted term 'x' does not occur in the simplified assertions and will\n not be included in vector 'v'."]
    pub fn yices_model_collect_defined_terms(mdl: *mut model_t, v: *mut term_vector_t);
}
extern "C" {
    #[doc = " Check whether a formula is satisfiable\n - f = formula\n - logic = SMT name for a logic (or NULL)\n - model = resulting model (or NULL if no model is needed)\n - delegate = external solver to use or NULL\n\n This function first checks whether f is trivially sat or trivially unsat.\n If not, it constructs a context configured for the specified logic, then\n asserts f in this context and checks whether the context is satisfiable.\n\n The return value is\n   STATUS_SAT if f is satisfiable,\n   STATUS_UNSAT if f is not satisifiable\n   STATUS_ERROR if something goes wrong\n\n If the formula is satisfiable and model != NULL, then a model of f is returned in *model.\n That model must be deleted when no-longer needed by calling yices_free_model.\n\n The logic must be either NULL or the name of an SMT logic supported by Yices.\n If the logic is NULL, the function uses a default context configuration.\n Ohterwise, the function uses a context specialized for the logic.\n\n The delegate is an optional argument used only when logic is \"QF_BV\".\n If is ignored otherwise. It must either be NULL or be the name of an\n external SAT solver to use after bit-blasting. Valid delegates\n are \"cadical\", \"cryptominisat\", and \"y2sat\".\n If delegate is NULL, the default SAT solver is used.\n\n Support for \"cadical\" and \"cryptominisat\" must be enabled at compilation\n time. The \"y2sat\" solver is always available. The function will return STATUS_ERROR\n and store an error code if the requested delegate is not available.\n\n Error codes:\n\n if f is invalid\n   code = INVALID_TERM\n   term1 = f\n\n if f is not Boolean\n   code = TYPE_MISMATCH\n   term1 = t\n   type1 = bool\n\n if logic is not a known logic name\n   code = CTX_UNKNOWN_LOGIC\n\n if the logic is known but not supported by Yices\n   code = CTX_LOGIC_NOT_SUPPORTED\n\n if delegate is not one of \"cadical\", \"cryptominisat\", \"y2sat\"\n   code = CTX_UNKNOWN_DELEGATE\n\n if delegate is \"cadical\" or \"cryptominisat\" but support for these SAT solvers\n was not implemented at compile time,\n   code = CTX_DELEGATE_NOT_AVAILABLE\n\n other error codes are possible if the formula is not in the specified logic (cf. yices_assert_formula)\n\n Since 2.6.2."]
    pub fn yices_check_formula(
        f: term_t,
        logic: *const ::std::os::raw::c_char,
        model: *mut *mut model_t,
        delegate: *const ::std::os::raw::c_char,
    ) -> smt_status_t;
}
extern "C" {
    #[doc = " Check whether n formulas are satisfiable.\n - f = array of n Boolean terms\n - n = number of elements in f\n\n This is similar to yices_check_formula except that it checks whether\n the conjunction of f[0] ... f[n-1] is satisfiable.\n\n Since 2.6.2."]
    pub fn yices_check_formulas(
        f: *const term_t,
        n: u32,
        logic: *const ::std::os::raw::c_char,
        model: *mut *mut model_t,
        delegate: *const ::std::os::raw::c_char,
    ) -> smt_status_t;
}
extern "C" {
    #[doc = " Check whether the given delegate is supported\n - return 0 if it's not supported.\n - return 1 if delegate is NULL or it's the name of a supported delegate\n\n Which delegate is supported depends on how this version of Yices was compiled.\n\n Since 2.6.2."]
    pub fn yices_has_delegate(delegate: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Bit-blast then export the CNF to a file\n - f = a Boolean formula (in the QF_BV theory)\n - filename = name of the ouput file\n - simplify_cnf = boolean flag\n - status = pointer to a variable that stores the formula's status\n\n The function bitblasts formula f and exports the resulting CNF to a file in DIMACS format.\n - filename = name of this file\n - simplify_cnf is a flag to enable CNF simplification using the y2sat SAT solver.\n   If simplify_cnf is 0, no CNF simplifcation is applied\n   If simplify_cnf is not 0, CNF simplification is applied\n\n The bit-vector solver applies various simplifications and preprocessing that may detect\n that f is SAT or UNSAT without generating a CNF. In this case, the function does not\n produce a DIMACS file and the formula status (either STATUS_SAT or STATUS_UNSAT) is\n returned in variable *status.\n\n If simplify_cnf is non-zero, it is also possible for CNF simplification to detect\n that the CNF is sat or unsat. In this case, no DIMACS file is produced and the status\n is returne in variable *status.\n\n Return code:\n   1 if the DIMACS file was constructed\n   0 if the formula is solved without CNF or after simplifying\n  -1 if there's an error\n\n Error reports:\n if f is not a valid term:\n   code = INVALID_TERM\n   term1 = f\n if f is not a Boolean term\n   code = TYPE_MISMATCH\n   term1 = f\n   type1 = bool (expected type)\n if there's an error when opening or writing to filename\n   code = OUTPUT_ERROR\n\n Other errors are possible if f can't be processed by the bitvector solver.\n\n Since 2.6.2."]
    pub fn yices_export_formula_to_dimacs(
        f: term_t,
        filename: *const ::std::os::raw::c_char,
        simplify_cnf: i32,
        status: *mut smt_status_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Bit-blast n formulas then export the CNF to a file\n - f = array of n Boolean formula (in the QF_BV theory)\n - n = number of formulas in f\n - filename = name of the ouput file\n - simplify_cnf = boolean flag\n - stat = pointer to a variable that stores the formula's status\n\n Return code:\n   1 if the DIMACS file was constructed\n   0 if the formula is solved without CNF or after simplifying\n  -1 if there's an error\n\n Error reports: same as for yices_export_formula_to_dimacs.\n\n Since 2.6.2."]
    pub fn yices_export_formulas_to_dimacs(
        f: *const term_t,
        n: u32,
        filename: *const ::std::os::raw::c_char,
        simplify_cnf: i32,
        status: *mut smt_status_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Value of boolean term t: returned as an integer val\n - val = 0 means t is false in mdl\n - val = 1 means t is true in mdl\n\n Error codes:\n If t is not boolean\n   code = TYPE_MISMATCH\n   term1 = t\n   type1 = bool (expected type)\n + the other evaluation error codes above."]
    pub fn yices_get_bool_value(mdl: *mut model_t, t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Value of arithmetic term t. The value can be returned as an integer, a\n rational (pair num/den), converted to a double, or using the GMP\n mpz_t and mpq_t representations, or as a libpoly algebraic number.\n\n Error codes:\n If t is not an arithmetic term:\n   code = ARITHTERM_REQUIRED\n   term1 = t\n If t's value does not fit in the *val object\n   code = EVAL_OVERFLOW"]
    pub fn yices_get_int32_value(mdl: *mut model_t, t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    pub fn yices_get_int64_value(mdl: *mut model_t, t: term_t, val: *mut i64) -> i32;
}
extern "C" {
    pub fn yices_get_rational32_value(
        mdl: *mut model_t,
        t: term_t,
        num: *mut i32,
        den: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn yices_get_rational64_value(
        mdl: *mut model_t,
        t: term_t,
        num: *mut i64,
        den: *mut u64,
    ) -> i32;
}
extern "C" {
    pub fn yices_get_double_value(mdl: *mut model_t, t: term_t, val: *mut f64) -> i32;
}
extern "C" {
    #[doc = " Value of bitvector term t in mdl\n - the value is returned in array val\n - val must be an integer array of sufficient size to store all bits of t\n   (the number of bits of t can be found by calling yices_term_bitsize).\n - bit i of t is stored in val[i] (val[i] is either 0 or 1)\n - the value is returned using small-endian convention:\n    val[0] is the low-order bit\n    ...\n    val[n-1] is the high-order bit\n\n If t is not a bitvector term\n   code = BITVECTOR_REQUIRED\n   term1 = t"]
    pub fn yices_get_bv_value(mdl: *mut model_t, t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Value of term t of uninterpreted or scalar type\n - the value is returned as a constant index in *val\n   (with the same meaning as in function yices_constant):\n - if t has type tau and tau is a scalar type of size n then\n   the function returns an index k between 0 and n-1\n - if tau is an uninterpreted type, then the function returns an\n   integer index k\n\n The index k is a unique identifier: if two terms t1 and t2 are not\n equal in the model mdl, then their values will be distinct indices k.\n\n Error codes:\n - if t does not have a scalar or uninterpreted type:\n   code = SCALAR_TERM_REQUIRED\n   term1 = t"]
    pub fn yices_get_scalar_value(mdl: *mut model_t, t: term_t, val: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Vectors of node descriptor: yices_val_expand_function requires\n a vector as argument. The following functions must be used\n to initialize, delete, or reset this vector. The conventions\n are the same as for vectors of terms or types."]
    pub fn yices_init_yval_vector(v: *mut yval_vector_t);
}
extern "C" {
    pub fn yices_delete_yval_vector(v: *mut yval_vector_t);
}
extern "C" {
    pub fn yices_reset_yval_vector(v: *mut yval_vector_t);
}
extern "C" {
    #[doc = " Value of term t as a node descriptor.\n\n The function returns 0 if t's value can be computed, -1 otherwise.\n If t's value can be computed, the corresponding node descriptor is\n returned in *val.\n\n Error codes are as in all evaluation functions.\n If t is not valid:\n   code = INVALID_TERM\n   term1 = t\n If t contains a subterm whose value is not known\n   code = EVAL_UNKNOWN_TERM\n If t contains free variables\n   code = EVAL_FREEVAR_IN_TERM\n If t contains quantifier(s)\n   code = EVAL_QUANTIFIER\n If t contains lambda terms\n   code = EVAL_LAMBDA\n If the evaluation fails for other reasons:\n   code = EVAL_FAILED"]
    pub fn yices_get_value(mdl: *mut model_t, t: term_t, val: *mut yval_t) -> i32;
}
extern "C" {
    #[doc = " Queries on the value of a rational node:\n - if v->node_tag is YVAL_RATIONAL, the functions below check whether v's value\n   can be converted to an integer or a pair num/den of the given size.\n - if v->node_tag != YVAL_RATIONAL, these functions return false (i.e. 0).\n\n yices_val_is_int32: check whether v's value fits in a signed, 32bit integer\n\n yices_val_is_int64: check whether v's value fits in a signed, 64bit integer\n\n yices_val_is_rational32: check whether v's value can be written num/den where num\n    is a signed 32bit integer and den is an unsigned 32bit integer\n\n yices_val_is_rational64: check whether v's value can be written num/den where num\n    is a signed 64bit integer and den is an unsigned 64bit integer\n\n yices_val_is_integer: check whether v's value is an integer"]
    pub fn yices_val_is_int32(mdl: *mut model_t, v: *const yval_t) -> i32;
}
extern "C" {
    pub fn yices_val_is_int64(mdl: *mut model_t, v: *const yval_t) -> i32;
}
extern "C" {
    pub fn yices_val_is_rational32(mdl: *mut model_t, v: *const yval_t) -> i32;
}
extern "C" {
    pub fn yices_val_is_rational64(mdl: *mut model_t, v: *const yval_t) -> i32;
}
extern "C" {
    pub fn yices_val_is_integer(mdl: *mut model_t, v: *const yval_t) -> i32;
}
extern "C" {
    #[doc = " Get the number of bits in a bv constant, the number of components in a tuple,\n or the arity of a mapping. These function return 0 if v has the wrong tag (i.e.,\n not a bitvector constant, or not a tuple, or not a mapping)."]
    pub fn yices_val_bitsize(mdl: *mut model_t, v: *const yval_t) -> u32;
}
extern "C" {
    pub fn yices_val_tuple_arity(mdl: *mut model_t, v: *const yval_t) -> u32;
}
extern "C" {
    pub fn yices_val_mapping_arity(mdl: *mut model_t, v: *const yval_t) -> u32;
}
extern "C" {
    #[doc = " Arity of a function node. This function returns 0 if v has tag\n other than YVAL_FUNCTION, otherwise it returns the function's\n arity (i.e., the number of parameters that the function takes)."]
    pub fn yices_val_function_arity(mdl: *mut model_t, v: *const yval_t) -> u32;
}
extern "C" {
    #[doc = " Type of a function node. This function returns -1 if v has tag\n other than YVAL_FUNCTION. Otherwise, it returns the type of the\n object v.\n\n Since 2.6.2."]
    pub fn yices_val_function_type(mdl: *mut model_t, v: *const yval_t) -> type_t;
}
extern "C" {
    #[doc = " Get the value of a Boolean node v.\n - returns 0 if there's no error and store v's value in *val:\n   *val is either 0 (for false) or 1 (for true).\n - returns -1 if v does not have tag YVAL_BOOL and sets the error code\n   to YVAL_INVALID_OP."]
    pub fn yices_val_get_bool(mdl: *mut model_t, v: *const yval_t, val: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Get the value of a rational node v\n - the functions return 0 if there's no error and store v's value in *val\n   or in the pair *num, *den (v's value is (*num)/(*den).\n - they return -1 if there's an error.\n\n The error code is set to YVAL_INVALID_OP if v's tag is not YVAL_RATIONAL.\n The error code is set to YVAL_OVERFLOW if v's value does not fit in\n (*val) or in (*num)/(*den)."]
    pub fn yices_val_get_int32(mdl: *mut model_t, v: *const yval_t, val: *mut i32) -> i32;
}
extern "C" {
    pub fn yices_val_get_int64(mdl: *mut model_t, v: *const yval_t, val: *mut i64) -> i32;
}
extern "C" {
    pub fn yices_val_get_rational32(
        mdl: *mut model_t,
        v: *const yval_t,
        num: *mut i32,
        den: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn yices_val_get_rational64(
        mdl: *mut model_t,
        v: *const yval_t,
        num: *mut i64,
        den: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = " Value converted to a floating point number"]
    pub fn yices_val_get_double(mdl: *mut model_t, v: *const yval_t, val: *mut f64) -> i32;
}
extern "C" {
    #[doc = " Get the value of a bitvector node:\n - val must have size at least equal to n = yices_val_bitsize(mdl, v)\n - v's value is returned in val[0] = low-order bit, ..., val[n-1] = high-order bit.\n   every val[i] is either 0 or 1.\n - the function returns 0 if v has tag YVAL_BV\n - it returns -1 if v has another tag and sets the error code to YVAL_INVALID_OP."]
    pub fn yices_val_get_bv(mdl: *mut model_t, v: *const yval_t, val: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Get the value of a scalar node:\n - the function returns 0 if v's tag is YVAL_SCALAR\n   the index and type of the scalar/uninterpreted constant are stored in *val and *tau, respectively.\n - the function returns -1 if v's tag is not YVAL_SCALAR and sets the error code to YVAL_INVALID_OP."]
    pub fn yices_val_get_scalar(
        mdl: *mut model_t,
        v: *const yval_t,
        val: *mut i32,
        tau: *mut type_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Expand a tuple node:\n - child must be an array large enough to store all children of v (i.e.,\n   at least n elements where n = yices_val_tuple_arity(mdl, v))\n - the children nodes of v are stored in child[0 ... n-1]\n\n Return code = 0 if v's tag is YVAL_TUPLE.\n Return code = -1 otherwise and the error code is then set to YVAL_INVALID_OP."]
    pub fn yices_val_expand_tuple(mdl: *mut model_t, v: *const yval_t, child: *mut yval_t) -> i32;
}
extern "C" {
    #[doc = " Expand a function node f\n - the default value for f is stored in *def\n - the set of mappings for f is stored in vector *v.\n   This vector must be initialized using yices_init_yval_vector.\n   The number of mappings is v->size and the mappings are stored\n   in v->data[0 ... n-1] where n = v->size\n\n Return code = 0 if v's tag is YVAL_FUNCTION.\n Return code = -1 otherwise and the error code is then set to YVAL_INVALID_OP."]
    pub fn yices_val_expand_function(
        mdl: *mut model_t,
        f: *const yval_t,
        def: *mut yval_t,
        v: *mut yval_vector_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Expand a mapping node m\n - the mapping is of the form [x_1 ... x_k -> v] where k = yices_val_mapping_arity(mdl, m)\n - tup must be an array of size at least k\n - the nodes (x_1 ... x_k) are stored in tup[0 ... k-1]\n   the node v is stored in val.\n\n Return code = 0 if v's tag is YVAL_MAPPING.\n Return code = -1 otherwise and the error code is then set to YVAL_INVALID_OP."]
    pub fn yices_val_expand_mapping(
        mdl: *mut model_t,
        m: *const yval_t,
        tup: *mut yval_t,
        val: *mut yval_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Check whether f is true in mdl\n - the returned value is\n     1 if f is true in mdl,\n     0 if f is false in mdl,\n    -1 if f's value can't be evaluated (then an error code is set)\n\n Error codes:\n - same as yices_get_bool_value"]
    pub fn yices_formula_true_in_model(mdl: *mut model_t, f: term_t) -> i32;
}
extern "C" {
    #[doc = " Check whether f[0 ... n-1] are all true in mdl\n - the returned value is as in the previous function:\n     1 if all f[i] are true\n     0 if one f[i] is false (and f[0 ... i-1] are all true)\n    -1 if one f[i] can't be evaluated (and f[0 ... i-1] are all true)\n\n Error codes:\n - same as yices_get_bool_value\n\n NOTE: if n>1, it's more efficient to call this function once than to\n call the previous function n times."]
    pub fn yices_formulas_true_in_model(mdl: *mut model_t, n: u32, f: *const term_t) -> i32;
}
extern "C" {
    #[doc = " Value of term t converted to a constant term val.\n\n For primitive types, this is the same as extracting the value\n then converting it to a constant term:\n - if t is a Boolean term, then val is either true or false (as\n   returned by functions yices_true() or yices_false()).\n - if t is an arithmetic term, then val is a rational or integer constant\n   (as built by functions yices_mpq or yices_mpz).\n - if t has uninterpreted or scalar type, then val is a constant term\n   of that type (as built by function yices_constant).\n - if t has a bitvector type, then val is a bitvector constant term\n   (as in yices_bvconst_from_array)\n\n Conversion of function values is not supported currently. So the\n function fails and returns NULL_TERM if t has a function type.\n\n If t has tuple type tau, then val is a tuple of constants (provided\n tau does not contain any function type).\n\n The function returns val, or NULL_TERM if there's an error.\n\n Error report\n   code = EVAL_CONVERSION_FAILED,\n   if the conversion to term fails (because it would require\n   converting a function to a term).\n"]
    pub fn yices_get_value_as_term(mdl: *mut model_t, t: term_t) -> term_t;
}
extern "C" {
    #[doc = " Get the values of terms a[0 .. n-1] in mdl and convert the values to terms.\n - a must be an array of n terms\n - b must be large enough to store n terms\n\n This function has the same behavior and limitations as yices_get_value_as_term.\n If there's no error, the function returns 0 and store the values in array b:\n - b[i] = value of a[i] in mdl, converted to a term\n\n Otherwise, the function returns -1 and sets the error report.\n The error codes are the same as for yices_get_value_as_term."]
    pub fn yices_term_array_value(
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
        b: *mut term_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Get the support of a term t in mdl\n - the support is returned in vector *v; v must be initialized by calling yices_init_term_vector.\n - if t is not a valid term, the function returns -1 and leaves v unchanged.\n - otherwise, the function returns 0 and the support of t is stored in *v:\n    v->size = number of terms in the support\n    v->data[0 ... v->size-1] = the terms\n\n Error report:\n if t is not a valid term:\n    code = INVALID_TERM\n    term1 = t\n\n Since 2.6.2."]
    pub fn yices_model_term_support(mdl: *mut model_t, t: term_t, v: *mut term_vector_t) -> i32;
}
extern "C" {
    #[doc = " Get the support of terms a[0...n-1] in mdl\n - the support is returned in vector *v;\n   v must be initialized by calling yices_init_term_vector.\n - if one  is not a valid term, the function returns -1 and leaves v unchanged.\n - otherwise, the function returns 0 and the support is stored in *v:\n    v->size = number of terms in the support\n    v->data[0 ... v->size-1] = the terms\n\n Error report:\n if a[i] is not a valid term,\n   code = INVALID_TERM\n   term1 = a[i]\n\n Since 2.6.2."]
    pub fn yices_model_term_array_support(
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
        v: *mut term_vector_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Compute an implicant for t in mdl\n - t must be a Boolean term that's true in mdl\n - the implicant is a list of Boolean terms a[0] ... a[n-1] such that\n    1) a[i] is a literal (atom or negation of an atom)\n    2) a[i] is true in mdl\n    3) the conjunction a[0] /\\ ... /\\ a[n-1] implies t\n\n The implicant is returned in vector v, which must be initialized by\n yices_init_term_vector:\n    v->size is the number of literals in the implicant (i.e., n)\n    v->data[0] ... v->data[n-1] = the n literals\n If there's an error (return code -1) then v is empty:\n    v->size is set to 0.\n\n The function returns 0 if the implicant can be computed. Otherwise\n it returns -1.\n\n Error report:\n if t is not valid\n   code = INVALID_TERM\n   term1 = t\n if t is not a Boolean term\n   code = TYPE_MISMATCH\n   term1 = t\n   type1 = bool\n if t is false in the model:\n   code = EVAL_NO_IMPLICANT\n any of the error codes for evaluation functions is also possible:\n   EVAL_UNKNOWN_TERM\n   EVAL_FREEVAR_IN_TERM\n   EVAL_QUANTIFIER\n   EVAL_LAMBDA\n   EVAL_FAILED"]
    pub fn yices_implicant_for_formula(mdl: *mut model_t, t: term_t, v: *mut term_vector_t) -> i32;
}
extern "C" {
    #[doc = " Variant: compute an implicant for an array of formulas in mdl.\n - n = size of the array\n - a[0 ... n-1] = n input terms.\n   each a[i] must be a Boolean term and must be true in mdl\n\n The function computes an implicant for the conjunction (and a[0] ... a[n-1]).\n\n Return codes and errors are as in the previous function.\n The implicant is returned in vector v.\n\n If the return code is 0, then\n    v->size = number of literals\n    v->data contains the array of literals.\n Otherwise, v->size is set to 0."]
    pub fn yices_implicant_for_formulas(
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
        v: *mut term_vector_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Compute a generalization of mdl for formula t\n - nelims = number of variables to eliminate\n - elim = variables to eliminate\n - each term in elim[i] must be an uninterpreted term (as returned by yices_new_uninterpreted_term)\n   of one of the following types: Boolean, (bitvector k), or Real\n - mode defines the generalization algorithm\n - v: term_vector to return the result\n\n The generalization G(X) is returned in term_vector v that must be initialized\n using yices_init_term_vector. G(X) is the conjunction of all formulas in v.\n    v->size = number of formulas returned\n    v->data[0] ....  v->data[v->size-1] = the formulas themselves.\n\n If mode = YICES_GEN_BY_PROJ, then every element of v is guaranteed to be a literal\n\n Important: t must be true in mdl, otherwise, the returned data may be garbage.\n\n Returned code:\n   0 means success\n  -1 means that the generalization failed."]
    pub fn yices_generalize_model(
        mdl: *mut model_t,
        t: term_t,
        nelims: u32,
        elim: *const term_t,
        mode: yices_gen_mode_t,
        v: *mut term_vector_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Compute a generalization of mdl for the conjunct (a[0] /\\ ... /\\ a[n-1])"]
    pub fn yices_generalize_model_array(
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
        nelims: u32,
        elim: *const term_t,
        mode: yices_gen_mode_t,
        v: *mut term_vector_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Pretty print type tau or term t on file f\n - width, height, offset define the print area\n - f = output file to use.\n   f must be open and writable.\n\n - return -1 on error\n - return 0 otherwise.\n\n - possible error report for yices_pp_type\n    code = INVALID_TYPE\n    type1 = tau\n\n - possible error report for yices_pp_term\n    code = INVALID_TERM\n    term1 = t\n\n - other errors (for both)\n    code = OUTPUT_ERROR if writing to file f failed.\n    in this case, errno, perror, etc. can be used for diagnostic."]
    pub fn yices_pp_type(f: *mut FILE, tau: type_t, width: u32, height: u32, offset: u32) -> i32;
}
extern "C" {
    pub fn yices_pp_term(f: *mut FILE, t: term_t, width: u32, height: u32, offset: u32) -> i32;
}
extern "C" {
    #[doc = " Pretty print an array of terms:\n - f = output file to use\n - n = number of terms in the array a\n - a = array of terms\n - width, height, offset define the print area\n - horiz = Boolean flag that determines the layout\n\n If horiz is true (non-zero), the terms are printed as follows\n     a[0]  a[1] .... a[k]\n     a[k+1] ... a[n-1]\n\n If horiz is false (zero), the terms are printed as follows\n     a[0]\n     a[1]\n      ...\n     a[n-1]\n\n The function first checks whether all terms in a[0... n-1] are\n valid.  If not, it sets the error report:\n    code = INVALID_TERM\n    term = a[i] (first invalid term in the array)\n and returns -1. Nothing is printed in this case.\n\n Otherwise, the terms a[0... n-1] are printed in the specified\n print area (some terms may be omitted if the area is too small).\n The function returns 0 unless there's an error while writing to\n file f. In such as case, the function returns -1 and\n set the error report to:\n    code = OUTPUT_ERROR\n"]
    pub fn yices_pp_term_array(
        f: *mut FILE,
        n: u32,
        a: *const term_t,
        width: u32,
        height: u32,
        offset: u32,
        horiz: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Print model mdl on FILE f\n - f must be open/writable\n\n The model stores a mapping from uninterpreted terms to values.\n This function will print the value of these uninterpreted terms,\n but it will skip the ones that don't have a name.\n\n To see the value of uninterpreted term x in the model, you have to\n give a name to 'x'. For example, this can be done by creating 'x'\n as follows:\n\n   x = yices_new_uninterpreted_term(<some type>)\n   yices_set_term_name(x, \"x\")\n\n This function will print a line of the form\n    (= <name of x> <value of x in mdl>)\n for every uninterpreted term 'x' that has a  value in the model,\n unless 'x' is a  function term.\n\n For function terms (i.e., if 'x' has a function type), then the yices_print_model\n will show a function definition as follows:\n\n   (function f\n     (type (-> t_0 ... t_k s))\n     (= (f <x_00> ... <x_0k>) v_0)\n       ...\n     (- (f <x_m0> ... <x_mk>) v_m)\n     (default w))\n\n where f is the function name.\n - the type (-> t_0 ... t_k s) is the type of f: the domain is t_0 .... t_k\n   and the range is s.\n - in every line (= (f <x_i0> ... x_ik>) v_i):\n      x_i0 is a constant of type t_0\n      ...\n      x_ik is a constant of type t_k\n      v_i  is a constant of type s\n - each such line specifies the value v_i of f at some point in its domain.\n - the last entry:  (default w)\n   is the default value of f at all points that are not listed above.\n\n Example:\n\n   (function b\n     (type (-> int bool))\n       (= (b 0) true)\n       (= (b 1) true)\n      (default false))\n\n means that b is a function from int to boo, such that (b 0) and (b 1) are true\n and (b i) is false for any i not equal to 0 or 1."]
    pub fn yices_print_model(f: *mut FILE, mdl: *mut model_t);
}
extern "C" {
    #[doc = " Pretty printing:\n - f = output file to use\n - width, height, offset define the print area\n\n return -1 on error, 0 otherwise\n\n Like yices_print_model, this function ignores the uninterpreted terms\n that don't have a name.\n\n On error:\n   code = OUTPUT_ERROR (means that writing to f failed)\n   in this case, errno, perror, etc. can be used for diagnostic."]
    pub fn yices_pp_model(
        f: *mut FILE,
        mdl: *mut model_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Print the values of n terms in  a model\n - f = output file\n - mdl = model\n - n = number of terms\n - a - array of n terms\n\n The function returns -1 on error, 0 otherwise.\n\n Error report:\n if a[i] is not a valid term:\n   code = INVALID_TERM\n   term1 = a[i]\n\n Since 2.6.2."]
    pub fn yices_print_term_values(
        f: *mut FILE,
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Pretty print the values of n terms in  a model\n - f = output file\n - mdl = model\n - n = number of terms\n - a - array of n terms\n - width, height, offset define the print area.\n\n This function is like yices_print_term_values except that is uses pretty printing.\n\n Return code: -1 on error, 0 otherwise\n\n\n Error report:\n if a[i] is not a valid term:\n   code = INVALID_TERM\n   term1 = a[i]\n if writing to f fails,\n   code = OUTPUT_ERROR\n   in this case, errno, perror, etc. can be used for diagnostic.\n\n Since 2.6.2."]
    pub fn yices_pp_term_values(
        f: *mut FILE,
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Variants of the above functions that use file descriptors rather than file pointers.\n\n These functions return 0 if successful or -1 if there's an error.\n Error codes are set as in the corresponding functions above.\n\n In particular, if fd is not a valid file descriptor or some other IO error happens,\n   code is set to OUTPUT_ERROR\n   and errno, perror can be used for diagnostic."]
    pub fn yices_pp_type_fd(
        fd: ::std::os::raw::c_int,
        tau: type_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> i32;
}
extern "C" {
    pub fn yices_pp_term_fd(
        fd: ::std::os::raw::c_int,
        t: term_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> i32;
}
extern "C" {
    pub fn yices_pp_term_array_fd(
        fd: ::std::os::raw::c_int,
        n: u32,
        a: *const term_t,
        width: u32,
        height: u32,
        offset: u32,
        horiz: i32,
    ) -> i32;
}
extern "C" {
    pub fn yices_print_model_fd(fd: ::std::os::raw::c_int, mdl: *mut model_t) -> i32;
}
extern "C" {
    pub fn yices_pp_model_fd(
        fd: ::std::os::raw::c_int,
        mdl: *mut model_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Since 2.6.2."]
    pub fn yices_print_term_values_fd(
        fd: ::std::os::raw::c_int,
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Since 2.6.2."]
    pub fn yices_pp_term_values_fd(
        fd: ::std::os::raw::c_int,
        mdl: *mut model_t,
        n: u32,
        a: *const term_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Convert type tau or term t to a string using the pretty printer.\n - width, height, offset define the print area as above.\n\n - return NULL on error\n - return a '\\0' terminated string otherwise\n   this string must be deleted by calling yices_free_string when it's no longer used\n\n - possible error report for yices_type_to_string\n    code = INVALID_TYPE\n    type1 = tau\n\n - possible error report for yices_term_to_string\n    code = INVALID_TERM\n    term1 = t\n"]
    pub fn yices_type_to_string(
        tau: type_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn yices_term_to_string(
        t: term_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert model to a string using the pretty printer.\n - width, height, offset define the print area\n\n Returns a '\\0'-terminated string otherwise. This string must be deleted\n when no longer needed by calling yices_free_string."]
    pub fn yices_model_to_string(
        mdl: *mut model_t,
        width: u32,
        height: u32,
        offset: u32,
    ) -> *mut ::std::os::raw::c_char;
}
